name,content
 Excel表列名称_1578048149469,"## 题目描述
<p>给定一个正整数，返回它在 Excel 表中相对应的列名称。</p>
<p>例如，</p>
<pre>    1 -&gt; A
    2 -&gt; B
    3 -&gt; C
    ...
    26 -&gt; Z
    27 -&gt; AA
    28 -&gt; AB 
    ...
</pre>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> 1
<strong>输出:</strong> ""A""
</pre>
<p><strong>示例&nbsp;2:</strong></p>
<pre><strong>输入:</strong> 28
<strong>输出:</strong> ""AB""
</pre>
<p><strong>示例&nbsp;3:</strong></p>
<pre><strong>输入:</strong> 701
<strong>输出:</strong> ""ZY""
</pre>"
 二进制求和_1578046703759,"## 题目描述
<p>给定两个二进制字符串，返回他们的和（用二进制表示）。</p>
<p>输入为<strong>非空</strong>字符串且只包含数字&nbsp;<code>1</code>&nbsp;和&nbsp;<code>0</code>。</p>
<p><strong>示例&nbsp;1:</strong></p>
<pre><strong>输入:</strong> a = ""11"", b = ""1""
<strong>输出:</strong> ""100""</pre>
<p><strong>示例&nbsp;2:</strong></p>
<pre><strong>输入:</strong> a = ""1010"", b = ""1011""
<strong>输出:</strong> ""10101""</pre>"
 计算各个位数不同的数字个数_1578056187275,"## 题目描述
<p>给定一个<strong>非负</strong>整数 n，计算各位数字都不同的数字 x 的个数，其中 0 ≤ x &lt; 10<sup>n&nbsp;</sup>。</p>
<p><strong>示例:</strong></p>
<pre><strong>输入: </strong>2
<strong>输出: </strong>91 
<strong>解释: </strong>答案应为除去 <code>11,22,33,44,55,66,77,88,99 </code>外，在 [0,100) 区间内的所有数字。
</pre>"
Array Poisonous Suffix Problem_1578242527621,"### 题目描述
Are you going to solve poisonous problems?
- Thanks a lot for today's poisonous problems.
What are you doing at the end of the world? Are you busy? Will you save us?
Ithea and Chtholly want to play a game in order to determine who will solve poisonous problems.
- Willem...
Lakhesh loves to make poisonous problems, so Nephren helps her run a cinema. We may call it No. 68 Cinema.
- I... I survived.
如题目背景所述，这是一道 PSP（Poisonous String Problem，毒瘤字符串题）。
对于一个正整数k，若任何一个1~n的排列均是某个字符集大小不超过k的字符串的后缀排名数组（后缀排名数组即后缀数组的逆排列，如果你不知道什么是后缀数组，可以自行搜索或参考Wiki 对后缀数组的介绍），
则称k对于n是毒瘤的。给定k，你需要找到一个最小的正整数n使k对于n不是毒瘤的，并且你需要给出1~n的一个排列，其不是任何一个字符集大小不超过k的字符串的后缀排名数组。如果有多个排列，输出字典序最小的，如果不存在这样的n和排列，输出 213。
### 输入描述
```
输入仅包含一个正整数k。
数据范围：对于所有数据，1≤k≤10^5。
```
### 输出描述
```
输出包含一至两行。
若无解，输出一行一个字符串 213。
若有解，第一行包含一个正整数n，之后一行n个空格隔开的正整数表示排列。
```
### 测试样例
#### 样例1:输入-输出-解释
```
1
```
```
2
1 2
```
```
字符集为1,长也为1的字符串a的后缀排名数组为1,包含了所有长为1的排列,所以k= 1对于n= 1毒瘤的。
字符集为1,长为2的唯一一个字符串aa的后缀排名数组为{2,1},故{1,2}不是任何字符集为1的字符串的后缀排名数组,所以k= 1对于n= 2不是毒瘤的,且{1,2}是此时唯一不是后缀排名数组的排列, 也是此时满足条件的字典序最小的排列。
```"
ASCII码的降序排列_1580740819534,"### 题目描述
给定的是一个长度为L的字符串。任务是从给定的字符串中找到最长的字符串，该字符串的字符按其ASCII码的降序排列并以算术级数排列。希望常见的差异应尽可能小（至少1），并且字符串的字符应具有较高的ASCII值。
### 输入描述
输入的第一行包含一个整数T，表示测试用例的数量。每个测试包含一个长度为L的字符串。
### 输出描述
对于每个测试用例，打印最长的字符串。
### 输入范例
```
2
ABCPQR
ADGJPRT
```
### 输出范例
```
RQP
JGDA
```
可能有两个最大长度的字符串-“ CBA”和“ RPQ”。但他希望该字符串具有较高的ASCII值，因此输出为“ RPQ”。
### 题目来源
geeksforgeeks.org
"
Excel表列序号_1578048275379,"## 题目描述
<p>给定一个Excel表格中的列名称，返回其相应的列序号。</p>
<p>例如，</p>
<pre>    A -&gt; 1
    B -&gt; 2
    C -&gt; 3
    ...
    Z -&gt; 26
    AA -&gt; 27
    AB -&gt; 28 
    ...
</pre>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> ""A""
<strong>输出:</strong> 1
</pre>
<p><strong>示例&nbsp;2:</strong></p>
<pre><strong>输入: </strong>""AB""
<strong>输出:</strong> 28
</pre>
<p><strong>示例&nbsp;3:</strong></p>
<pre><strong>输入: </strong>""ZY""
<strong>输出:</strong> 701</pre>"
graph_1578215353563,"### 题目描述
给定一张n个点，m条边的无向图，边有边权，每一个点都有一种颜色c_i(符号""_""表示下标)。
一个友好点对是指一个无序点对其为两个点的颜色差≥L。
两个点之间的最短路径定义为最小的权值d使得存在一条只经过权值≤d的边的路径。
求所有友好点对之间最短路径之和。
### 输入描述
```
输入的第一行给出三个数，即上述的n,m,L。
接下来一行有n个数，表示每一个点的颜色c_i。
接下来m行表示每条边，每行将给出三个数u_i,v_i,w_i，表示点u_i和点v_i之间有一条长为w_i的边。
保证整张图连通。
数据范围：
1≤n≤200000
1≤m≤400000
1≤w_i, c_i≤10^8
```
### 输出描述
```
输出一个数，表示所有友好点对之间的最短路径之和。
```
### 测试样例
#### 样例1:输入-输出-解释
```
4 5 2
6 4 5 2
1 2 8
2 3 7
2 4 8
1 3 2
1 4 1
```
```
17
```"
honoka的键盘_1581142653945,"### 题目描述
honoka 有一个只有两个键的键盘。
一天，她打出了一个只有这两个字符的字符串。当这个字符串里含有""VK""这个字符串的时候，honoka 就特别喜欢这个字符串。所以，她想改变至多一个字符（或者不做任何改变）来最大化这个字符串内""VK""出现的次数。给出原来的字符串，请计算她最多能使这个字符串内出现多少次""VK""。(只有当""V""和""K""正好相邻时，我们认为出现了""VK""。)
### 输入描述
```
第一行给出一个数字 n,代表字符串的长度。第二行给出一个字符串 s。
```
### 输出描述
```
第一行输出一个整数代表所求答案。
```
### 测试样例
#### 样例1:输入-输出-解释
```
2
VK
```
```
1
```
```
无
```
#### 样例1:输入-输出-解释
```
20
VKKKKKKKKKVVVVVVVVVK
```
```
3
```
```
无
```
### 题目来源  
`luogu.com.cn`"
H指数 II_1580454989013,"### 题目描述
<p>给定一位研究者论文被引用次数的数组（被引用次数是非负整数），数组已经按照<strong>升序排列</strong>。编写一个方法，计算出研究者的 <em>h</em> 指数。</p>
<p><a href=""https://baike.baidu.com/item/h-index/3991452?fr=aladdin"">h 指数的定义</a>: “h 代表“高引用次数”（high citations），一名科研人员的 h 指数是指他（她）的 （N 篇论文中）<strong>至多</strong>有 h 篇论文分别被引用了<strong>至少</strong> h 次。（其余的&nbsp;<em>N - h&nbsp;</em>篇论文每篇被引用次数<strong>不多于 </strong><em>h </em>次。）""</p>
<p>&nbsp;</p>
<p><strong>示例:</strong></p>
<pre><strong>输入:</strong> <code>citations = [0,1,3,5,6]</code>
<strong>输出:</strong> 3 
<strong>解释: </strong>给定数组表示研究者总共有 <code>5</code> 篇论文，每篇论文相应的被引用了 0<code>, 1, 3, 5, 6</code> 次。
&nbsp;    由于研究者有 <code>3 </code>篇论文每篇<strong>至少</strong>被引用了 <code>3</code> 次，其余两篇论文每篇被引用<strong>不多于</strong> <code>3</code> 次，所以她的<em> h </em>指数是 <code>3</code>。</pre>
<p>&nbsp;</p>
<p><strong>说明:</strong></p>
<p>如果 <em>h </em>有多有种可能的值 ，<em>h</em> 指数是其中最大的那个。</p>
<p>&nbsp;</p>
<p><strong>进阶：</strong></p>
<ul>
	<li>这是&nbsp;<a href=""/problems/h-index/description/"">H指数</a>&nbsp;的延伸题目，本题中的&nbsp;<code>citations</code>&nbsp;数组是保证有序的。</li>
	<li>你可以优化你的算法到对数时间复杂度吗？</li>
</ul>
### 样例输入<br>
```
0,1,3,5,6
```
### 样例输出<br>
```
3
```
### 题目来源  
`LeetCode`"
Inversion of array_1580210123436,"### 题目描述
给定正整数数组。任务是找到数组的反转计数。 反转计数：对于数组，反转计数指示数组要排序的距离（或距离）。如果数组已经排序，则反转计数为0。如果数组以相反顺序排序，则反转计数为最大。 形式上，如果a [i]> a [j]且i <j，则两个元素a [i]和a [j]形成一个反转。
### 输入描述
输入的第一行包含一个整数T，表示测试用例的数量。每个测试用例的第一行是N，即数组的大小。每个测试用例的第二行包含N个元素。
### 输出描述
打印数组的反转计数。
### 输入范例
```
1
5
2 4 1 3 5
```
### 输出范例
```
3
```
### 题目来源
geeksforgeeks.org
"
k个最大元素_1580285444507,"### 题目描述
给定一个由N个正整数组成的数组，请从该数组中打印k个最大的元素。输出元素应按降序打印。
### 输入描述
输入的第一行包含一个整数T，表示测试用例的数量。每个测试用例的第一行是N和k，N是数组的大小，K是要返回的最大元素。每个测试用例的第二行包含N个输入C [i]。
### 输出描述
按降序打印最大的k个元素。
### 输入范例
```
2
5 2
12 5 787 1 23
7 3
1 23 12 9 30 2 50
```
### 输出范例
```
787 23
50 30 23
```
### 题目来源
geeksforgeeks.org
"
LJJ的字符串_1578287657460,"### 题目描述
LJJ拿到了一串来自火星的字符串。
字符串中，每个字符都是一种火星字母, LJJ 将其转换为小写英文字母a ~ z,为了便于发现其中的奥秘。
仔细看，这个字符串杂乱中带着有序，有许多重复的片段。于是，LJJ请来了作为字符串分析专家的你，来帮他分析计算这个字符串的神秘度。
设n是这个字符串的长度。设S[i, j]表示字符串S中第i个位置到第j个位置的连续子串(字符串下标从1开始)。
若i,j, len同时满足:
	1 ≤ i < j ≤ i+len-1 < j+len-1 ≤ n
	S[i,i+len-1] = S[j,j+len-1]
则这个三元数对(i, j, len)对S的神秘度的贡献是len。
输入一个字符串，输出其所有前缀的神秘度。由于这个值过大,所以请对10^9 + 7取模并输出。
### 输入描述
```
输入仅一行：仅由小写字母构成的字符串S。
```
### 输出描述
```
输出共n行，第i行的整数是前i个位置表示的前缀的神秘度。
```
### 测试样例
#### 样例1:输入-输出-解释
```
aaaaaa
```
```
0
0
2
7
19
40
```"
Nim 游戏_1580703874230,"### 题目描述
<p>你和你的朋友，两个人一起玩&nbsp;<a href=""https://baike.baidu.com/item/Nim游戏/6737105"">Nim 游戏</a>：桌子上有一堆石头，每次你们轮流拿掉&nbsp;1 - 3 块石头。 拿掉最后一块石头的人就是获胜者。你作为先手。</p>
<p>你们是聪明人，每一步都是最优解。 编写一个函数，来判断你是否可以在给定石头数量的情况下赢得游戏。</p>
<p><strong>示例:</strong></p>
<pre><strong>输入:</strong> <code>4</code>
<strong>输出:</strong> False 
<strong>解释: </strong>如果堆中有 4 块石头，那么你永远不会赢得比赛；
&nbsp;    因为无论你拿走 1 块、2 块 还是 3 块石头，最后一块石头总是会被你的朋友拿走。
</pre>
### 样例输入<br>
```
4
```
### 样例输出<br>
```
False
```
### 题目来源  
`LeetCode`"
"Pow(x, n)_1577688408110","## 题目描述
<p>实现&nbsp;<a href=""https://www.cplusplus.com/reference/valarray/pow/"">pow(<em>x</em>, <em>n</em>)</a>&nbsp;，即计算 x 的 n 次幂函数。</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> 2.00000, 10
<strong>输出:</strong> 1024.00000
</pre>
<p><strong>示例&nbsp;2:</strong></p>
<pre><strong>输入:</strong> 2.10000, 3
<strong>输出:</strong> 9.26100
</pre>
<p><strong>示例&nbsp;3:</strong></p>
<pre><strong>输入:</strong> 2.00000, -2
<strong>输出:</strong> 0.25000
<strong>解释:</strong> 2<sup>-2</sup> = 1/2<sup>2</sup> = 1/4 = 0.25</pre>
<p><strong>说明:</strong></p>
<ul>
	<li>-100.0 &lt;&nbsp;<em>x</em>&nbsp;&lt; 100.0</li>
	<li><em>n</em>&nbsp;是 32 位有符号整数，其数值范围是&nbsp;[−2<sup>31</sup>,&nbsp;2<sup>31&nbsp;</sup>− 1] 。</li>
</ul>"
Samjia和矩阵_1578283732786,"### 题目描述
给你一个只包含大写字母的矩阵，求有多少本质不同的子矩阵。
### 输入描述
```
第一行包含两个整数n,m,表示矩阵n行m列 。
接下来n行描述这个矩阵。
```
### 输出描述
```
只含一个整数，为本质不同的子矩阵个数。
```
### 测试样例
#### 样例1:输入-输出-解释
```
3 3
ABA
BAA
AAA
```
```
22
```"
The Bridge on the River Kawaii_1578231113186,"### 题目描述
在一个遥远的，叫做 Midsommer 的地方，有一条叫做 delta 的小河。河里流的是深紫色的酸，所以不可能在那里游泳。这条河周围有一些小岛，并且有桥连接它们。每座桥都有一个危险系数，表示通过这座桥有多危险。危险系数越高，通过这座桥就越危险。
一位叫做 Richard Hradecki 的侦探兼悬疑小说作家经常需要通过这些桥来追查案件。在所有可能的路径中，他更倾向于选择最安全的一条，也就是这条路径上经过桥的最大危险系数越低越好。
为了规划路线，Richard 经常让你为他找从一个岛到他要调查的岛的最安全路线。为了满足他的需求，你需要连续处理以下三种事件：
    当地人在两座岛屿之间建了一座新桥；
    一只酸性的并且毛茸茸的大粉熊 Lug 出现了，并摧毁了一座桥；
    Richard 要求你找两个岛屿之间的最安全路线。
### 输入描述
```
第一行包含两个整数N,Q。N是岛屿数(岛屿用0...N - 1标号)，Q是需要处理的事件数。
接下来Q行，每行表示一个事件,包含三或四个整数,说明如下:
● 0 X Y V:在X岛与Y岛之间刚建成一座危险系数为V的桥;
● 1 X Y:连接X, Y两岛的桥刚被摧毁;
● 2 X Y: Richard询问从X到Y的最安全路径。
对于所有类型的询问，X, Y表示一对合法的岛屿。保证任意两个岛屿之间最多只存在一座直达的桥，要被摧毁的桥在那一刻是存在的。
数据范围：2≤N≤10^5, 1≤Q≤10^5, 0≤V<10, 0≤X,Y<N, X≠Y
```
### 输出描述
```
对于每个种类为2的事件，输出X到Y最安全路径上经过的最危险的桥的危险系数。如果X与Y之间没有路径，输出-1。
```
### 测试样例
#### 样例1:输入-输出-解释
```
6 15
0 1 2 1
2 1 4
2 1 5
0 2 3 2
2 1 4
2 1 5
0 3 4 3
2 1 4
2 1 5
0 4 5 4
2 1 4
2 1 5
1 4 5
2 1 4
2 1 5
```
```
-1
-1
-1
-1
3
-1
3
4
3
-1
```"
TheABCDMurderer_1578289301451,"### 题目描述
Oscar 特别喜欢看犯罪电影。他钦佩那些罪犯，因为他们富有创造力。他也想展示他的创造力。但很可惜的是，他没什么经验，也想不出来什么原创伎俩。所以他想从已有的招数中寻找灵感。他一直喜欢看罪犯从报纸上剪下字母，然后用这些字母拼勒索信的桥段。然而 Oscar 根本不想抄袭，所以他自己想了一个这种方法的变体。他觉得把字母一个一个拼成文本既无聊又费时间。所以他决定通过剪下一整个单词的方式拼出自己的勒索信。
Oscar 买来一些主流报纸，这样他几乎就有了无限的单词库。他可以多次剪出任意特定的单词。然而，他还是被报纸中出现的的单词集限制。问题是一些单词根本没在报纸中出现。为了让这项工作更简单，他决定去除勒索信中所有的标点符号和空格并且忽略字母的大小写。他同时允许剪出的单词互相重叠，只需要重叠部分相同。现在 Oscar 想知道他至少要剪下多少次单词才能拼成他想要的勒索信。
### 输入描述
```
第一行包含一个整数L，表示在报纸中发现的单词数；
下一行包含勒索信的内容s。保证内容非空并且只包含小写英文字母。
接下来L行，每行包含一个在报纸中出现的单词a_i(符号""_""表示下标)，保证只出现小写英文字母。这些单词中没有空串，也没有比勒索信长的单词。所有报纸中单词在输入中出现至少一次。
```
### 输出描述
```
输出 Oscar 最少要从报纸中剪下多少次单词才能组成勒索信、如果不能组成，输出-1。每个单词都要被记实际从报纸剪下那么多次。
```
### 测试样例
#### 样例1:输入-输出-解释
```
3
aaaaa
a
aa
aaa
```
```
2
```"
x 的平方根_1578047147585,"## 题目描述
<p>实现&nbsp;<code>int sqrt(int x)</code>&nbsp;函数。</p>
<p>计算并返回&nbsp;<em>x</em>&nbsp;的平方根，其中&nbsp;<em>x </em>是非负整数。</p>
<p>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> 4
<strong>输出:</strong> 2
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong> 8
<strong>输出:</strong> 2
<strong>说明:</strong> 8 的平方根是 2.82842..., 
&nbsp;    由于返回类型是整数，小数部分将被舍去。
</pre>"
X1序列_1578275363480,"## 题目描述
给定一系列数字2、10、30、68、130 ..，请确定该系列中的模式并帮助标识其他索引处的整数。索引从1开始。
## 输入描述
输入行包含T，表示测试用例的数量。每个测试用例的描述如下。每个测试用例包含一行带有1个整数X（索引）的行。1 ≤ T ≤ 200；1 ≤ X ≤ 200
## 输出描述
对于新行中的每个测试用例，在第X个索引处打印数字。
## 样例输入
4
8 
12
200
145
## 样例输出
520
1740
8000200
3048770
## 题目来源
geeksforgeeks.org"
Xor运算_1579951483405,"### 题目描述
给定一个数组A []，构造一个新的数组A2 []。 A2 []中的值是通过对数组中连续元素进行Xor运算获得的。
### 输入描述
输入的第一行包含t，即测试用例的数量。测试用例的每一行都包含一个数字n，该数字指定元素的数量。 每'n'行表示数组A []的元素。
1<=t<=100
1<=n<=100000
1<=A[i]<=100000
### 输出描述
输出的每一行都包含数组A2 []的元素。
### 输入范例
```
1
5
10 11 1 2 3
```
### 输出范例
```
1 10 3 1 3
```
### 题目来源
https://practice.geeksforgeeks.org/"
一个简单的分数_1580476514307,"### 题目描述
给出分数。将其转换为小数。
这么简单：P 
例如。 
10/2 = 5 
3/5 = 0.6 
（问题从现在开始）：D 
如果小数递归重复，则将它们放在（）内。 
例如。 
8/3 = 2.（6） 
作为8/3 = 2.66666666 .......无限。
### 输入描述
输入的第一行包含一个整数T，表示测试用例的数量。 
每个测试用例的第一行是一个整数N，表示分数的分子。 
每个测试用例的第二行是一个整数D，表示分数的分母。
### 输出描述
对于每个测试用例，请在单独的行中打印该分数的小数。
### 输入范例
```
2
4
2
8
3
```
### 输出范例
```
2
2.(6)
```
### 题目来源
geeksforgeeks.org
"
三元组计数_1580285767832,"### 题目描述
给定一个由不同整数组成的数组。任务是对所有三元组进行计数，以使两个元素的总和等于第三个元素。
### 输入描述
输入的第一行包含一个整数T，表示测试用例的数量。然后是T测试用例。每个测试用例由两行组成。每个测试用例的第一行包含一个整数N，表示数组的大小，第二行包含N个以空格分隔的元素。
### 输出描述
对于每个测试用例，在新行中打印所有三胞胎的计数。如果无法形成这样的三元组，请打印“ -1”。 
限制条件： 
1 <= T <= 100 
3 <= N <= 10^5 
1 <= A [i] <= 10^6
### 输入范例
```
2
4
1 5 3 2
3
3 2 7
```
### 输出范例
```
2
-1
```
### 题目来源
geeksforgeeks.org
"
三大候选人_1580437067105,"### 题目描述
谷歌的招聘团队旨在寻找3名出色的候选人。每个候选人的能力都用整数表示。如果他们的能力乘积最大，则3名候选人总的来说是令人满意的。给定N个候选人的能力，从给定的候选人池中找到最大的集体能力。
### 输入描述
输入的第一行包含一个整数T，表示测试用例的数量。然后是T测试用例。每个测试用例的第一行包含一个整数N，表示候选数。 每个测试用例的第二行包含N个空格分隔的元素，表示候选者的能力。
### 输出描述
对应每个测试用例，在换行符中打印所需的输出（三个候选者的最大集体能力）。
### 输入范例
```
1
6
0 -1 3 100 70 50
```
### 输出范例
```
350000
```
### 题目来源
geeksforgeeks.org
"
丑数 II_1578051262854,"## 题目描述
<p>编写一个程序，找出第 <code>n</code> 个丑数。</p>
<p>丑数就是只包含质因数&nbsp;<code>2, 3, 5</code> 的<strong>正整数</strong>。</p>
<p><strong>示例:</strong></p>
<pre><strong>输入:</strong> n = 10
<strong>输出:</strong> 12
<strong>解释: </strong><code>1, 2, 3, 4, 5, 6, 8, 9, 10, 12</code> 是前 10 个丑数。</pre>
<p><strong>说明:&nbsp;</strong>&nbsp;</p>
<ol>
	<li><code>1</code>&nbsp;是丑数。</li>
	<li><code>n</code>&nbsp;<strong>不超过</strong>1690。</li>
</ol>"
丑数_1578051147092,"## 题目描述
<p>编写一个程序判断给定的数是否为丑数。</p>
<p>丑数就是只包含质因数&nbsp;<code>2, 3, 5</code>&nbsp;的<strong>正整数</strong>。</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> 6
<strong>输出:</strong> true
<strong>解释: </strong>6 = 2 ×&nbsp;3</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong> 8
<strong>输出:</strong> true
<strong>解释: </strong>8 = 2 × 2 ×&nbsp;2
</pre>
<p><strong>示例&nbsp;3:</strong></p>
<pre><strong>输入:</strong> 14
<strong>输出:</strong> false 
<strong>解释: </strong><code>14</code> 不是丑数，因为它包含了另外一个质因数&nbsp;<code>7</code>。</pre>
<p><strong>说明：</strong></p>
<ol>
	<li><code>1</code>&nbsp;是丑数。</li>
	<li>输入不会超过 32 位有符号整数的范围:&nbsp;[−2<sup>31</sup>,&nbsp; 2<sup>31&nbsp;</sup>− 1]。</li>
</ol>"
两个排序数组的第K个元素_1580456827109,"### 题目描述
给定两个分别为大小M和N的排序数组A和B以及元素k。我们的任务是找到位于最终排序数组第k个位置的元素。
### 输入描述
第一行由测试用例T组成。每个测试用例的第一行由3个整数N，M和K组成，分别表示A中的元素数M，B中的元素数N和第k个位置元素。每个测试用例的第二行和第三行分别由A和B元素组成。
### 输出描述
将元素打印在第K个位置。
### 输入范例
```
1
5 4 5
2 3 6 7 9
1 4 8 10
```
### 输出范例
```
6
```
### 题目来源
geeksforgeeks.org
"
两个数组的交集_1580487351779,"### 题目描述
给定两个数组，编写一个函数来计算它们的交集。
### 输入描述
```
两行分别为两个数组
```
### 输出描述
```
计算出的交集数组，数组元素从小到大排列。
```
### 测试样例
#### 样例1: 输入-输出-解释
```
[4,9,5]
[9,4,9,8,4]
```
```
[4,9]
```
```
输出结果中的每个元素一定是唯一的。输出数组元素从小到大排列。
```"
两数之和 II - 输入有序数组_1580454077011,"### 题目描述
<p>给定一个已按照<strong><em>升序排列</em>&nbsp;</strong>的有序数组，找到两个数使得它们相加之和等于目标数。</p>
<p>函数应该返回这两个下标值<em> </em>index1 和 index2，其中 index1&nbsp;必须小于&nbsp;index2<em>。</em></p>
<p><strong>说明:</strong></p>
<ul>
	<li>返回的下标值（index1 和 index2）不是从零开始的。</li>
	<li>你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。</li>
</ul>
<p><strong>示例:</strong></p>
<pre><strong>输入:</strong> numbers = [2, 7, 11, 15], target = 9
<strong>输出:</strong> [1,2]
<strong>解释:</strong> 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。</pre>
### 样例输入<br>
```
2, 7, 11, 15
9
```
### 样例输出<br>
```
[1, 2]
```
### 题目来源  
`LeetCode`"
两数相除_1577685525513,"## 题目描述
<p>给定两个整数，被除数&nbsp;<code>dividend</code>&nbsp;和除数&nbsp;<code>divisor</code>。将两数相除，要求不使用乘法、除法和 mod 运算符。</p>
<p>返回被除数&nbsp;<code>dividend</code>&nbsp;除以除数&nbsp;<code>divisor</code>&nbsp;得到的商。</p>
<p><strong>示例&nbsp;1:</strong></p>
<pre><strong>输入:</strong> dividend = 10, divisor = 3
<strong>输出:</strong> 3</pre>
<p><strong>示例&nbsp;2:</strong></p>
<pre><strong>输入:</strong> dividend = 7, divisor = -3
<strong>输出:</strong> -2</pre>"
乘积相同_1580305907167,"### 题目描述
给定正整数数组，判断是否有两个数字的乘积等于给定值。
### 输入描述
输入的第一行包含一个整数T，表示测试用例的数量。 每个测试用例的第一行是N和乘积P。 每个测试用例的第二行包含数组元素
### 输出描述
如果存在两个数字乘积等于P，则打印“Yes”（不带引号），否则，请打印“No”（不带引号）。
### 输入范例
```
2
5 25
1 2 3 4 5
8 63
5 7 9 22 15 344 92 8
```
### 输出范例
```
No
Yes
```
### 题目来源
geeksforgeeks.org
"
事情的相似度_1578283308031,"### 题目描述
人的一生不仅要靠自我奋斗，还要考虑到历史的行程。
历史的行程可以抽象成一个 01 串，作为一个年纪比较大的人，你希望从历史的行程中获得一些姿势。
你发现在历史的不同时刻，不断的有相同的事情发生。比如，有两个人同时在世纪之交 11 年的时候上台，同样喜欢与洋人谈笑风生，同样提出了以「三」字开头的理论。
你发现，一件事情可以看成是这个 01 串的一个前缀，这个前缀最右边的位置就是这个事情的结束时间。
两件事情的相似度可以看成，这两个前缀的最长公共后缀长度。
现在你很好奇，在一段区间内结束的事情中最相似的两件事情的相似度是多少呢？
### 输入描述
```
第一行两个整数n、m,表示串长和询问个数。
第二行长度为n的01串，表示历史的行程。
接下来m行,每行两个正整数l、r表示询问的区间,包括端点，保证1≤l< r≤n。
```
### 输出描述
```
输出m行，对每个询问输出一个整数表示最大的相似度。
```
### 测试样例
#### 样例1:输入-输出-解释
```
4 2
0101
1 3
2 4
```
```
1
2
```"
二分图匹配超级英雄_1578039155099,"### 题目描述
节目「超级英雄」的大概流程是：选手回答主持人的几个问题，答对问题越多，奖品或奖金越丰厚。主持人准备了若干道题目，选手必须正确回答一道题才能作答下一题，否则就被淘汰。为了增加节目的趣味性并适当降低难度，主持人总会给选手提供几个「锦囊妙计」。
这里，我们稍微改变一下规则。假设主持人总共有m道题，选手有n种不同的「锦囊妙计」，编号为0 ~ n-1。每种「锦囊妙计」只能用一次。每道题都只有两种「锦囊妙计」可以使用（两者可能一样），但每道题只能使用一种「锦囊妙计」。假设一道题使用了它允许的锦囊妙计后，就一定能正确回答，顺利进入下一题。
现在我来到了节目现场，可是我蠢得一道题都不会，只好每道题都借助「锦囊妙计」来过关。如果我事先知道每道题能够使用哪两种「锦囊妙计」，那么你能告诉我怎样选择才能通过最多的题数吗？
### 输入描述
```
输入文件的一行是两个正整数n和m(1≤n≤1000,1≤m≤1000)。
以下的m行,每行两个数，分别表示第m个问题可以使用的「锦囊妙计」的编号。
数据范围：1≤n≤1000,1≤m≤1000。
```
### 输出描述
```
第一行为最多能通过的题数p。
```
### 测试样例
#### 样例1:输入-输出-解释
```
5 6 
3 2
2 0 
0 3 
0 4
3 2
3 2
```
```
4
```"
二叉搜索树_1580182725545,"### 题目描述
判断两序列是否为同一二叉搜索树序列
### 输入描述
```
开始一个数n，(1<=n<=20) 表示有n个需要判断，n= 0 的时候输入结束。
接下去一行是一个序列，序列长度小于10，包含(0~9)的数字，没有重复数字，根据这个序列可以构造出一颗二叉搜索树。
接下去的n行有n个序列，每个序列格式跟第一个序列一样，请判断这两个序列是否能组成同一颗二叉搜索树。
```
### 输出描述
```
如果序列相同则输出YES，否则输出NO
```
### 测试样例
#### 样例1:输入-输出-解释
```
2
567432
543267
576342
0
```
```
YES
NO
```
```
无
```
### 题目来源  
`nowcoder.com`"
二叉树_1580096769533,"### 题目描述
<p align=""left"">
 <img src=""http://mooctest-code.oss-cn-shanghai.aliyuncs.com/static/media/tree/%E4%BA%8C%E5%8F%89%E6%A0%91.png"" alt=""Sample""  width=""200"" height=""120"">
</p >
如上所示，由正整数1，2，3……组成了一颗特殊二叉树。我们已知这个二叉树的最后一个结点是n。现在的问题是，结点m所在的子树中一共包括多少个结点。     比如，n = 12，m = 3那么上图中的结点13，14，15以及后面的结点都是不存在的，结点m所在子树中包括的结点有3，6，7，12，因此结点m的所在子树中共有4个结点。
### 输入描述
```
输入数据包括多行，每行给出一组测试数据，包括两个整数m，n (1 <= m <= n <= 1000000000)。
```
### 输出描述
```
对于每一组测试数据，输出一行，该行包含一个整数，给出结点m所在子树中包括的结点的数目。
```
### 测试样例
#### 样例1:输入-输出-解释
```
3 12
0 0
```
```
4
```
```
无
```
### 题目来源  
`nowcoder.com`"
二叉树遍历_1580183600465,"### 题目描述
编一个程序，读入用户输入的一串先序遍历字符串，根据此字符串建立一个二叉树（以指针方式存储）。 例如如下的先序遍历字符串： ABC##DE#G##F### 其中“#”表示的是空格，空格字符代表空树。建立起此二叉树以后，再对二叉树进行中序遍历，输出遍历结果。
### 输入描述
```
输入包括1行字符串，长度不超过100。
```
### 输出描述
```
可能有多组测试数据，对于每组数据，
输出将输入字符串建立二叉树后中序遍历的序列，每个字符后面都有一个空格。
每个输出结果占一行。
```
### 测试样例
#### 样例1:输入-输出-解释
```
abc##de#g##f###
```
```
c b e g d f a 
```
```
无
```
### 题目来源  
`nowcoder.com`"
二逼平衡树_1578919897355,"### 题目描述
您需要写一种数据结构（可参考题目标题），来维护一个有序数列，其中需要提供以下操作：
1.查询x在区间内的排名；
2.查询区间内排名为k的值；
3.修改某一位置上的数值；
4.查询x在区间内的前趋（前趋定义为小于x，且最大的数）；
5.查询x在区间内的后继（后继定义为大于x，且最小的数）。
### 输入描述
```
第一行两个数n,m，表示长度为n的有序序列和m个操作。
第二行有n个数，表示有序序列。
下面有m行，每行第一个数表示操作类型：
1.之后有三个数l,r,x表示查询x在区间[l,r]的排名；
2.之后有三个数l,r,k表示查询区间[l,r]内排名为k的数；
3.之后有两个数pos,x表示将pos位置的数修改为x；
4.之后有三个数l,r,x表示查询区间[l,r]内x的前趋；
5.之后有三个数l,r,x表示查询区间[l,r]内x的后继。
```
### 输出描述
```
对于操作1,2,4,5各输出一行，表示查询结果。
```
### 测试样例
#### 样例1:输入-输出-解释
```
9 6
4 2 2 1 9 4 0 1 1
2 1 4 3
3 4 10
2 1 4 3
1 2 5 9
4 3 9 5
5 2 8 5
```
```
2
4
3
4
9
```"
交换字符串中的元素_1580893832086,"### 题目描述
给你一个字符串 s，以及该字符串中的一些「索引对」数组 pairs，其中 pairs[i] = [a, b] 表示字符串中的两个索引（编号从 0 开始）。
你可以 任意多次交换 在 pairs 中任意一对索引处的字符。
返回在经过若干次交换后，s 可以变成的按字典序最小的字符串。
### 输入描述
```
一个字符串 s，以及该字符串中的一些「索引对」数组 pairs，其中 pairs[i] = [a, b] 表示字符串中的两个索引（编号从 0 开始）。
1 <= s.length <= 10^5
0 <= pairs.length <= 10^5
0 <= pairs[i][0], pairs[i][1] < s.length
s 中只含有小写英文字母
```
### 输出描述
```
返回在经过若干次交换后，s 可以变成的按字典序最小的字符串。
```
### 测试样例
#### 样例1: 输入-输出-解释
```
dcab
[[0,3],[1,2]]
```
```
bacd
```
```
交换 s[0] 和 s[3], s = ""bcad""
交换 s[1] 和 s[2], s = ""bacd""
```
### 题目来源  
`LeetCode`"
冒泡排序_1580373360926,"### 题目描述
冒泡排序是一种能对数列进行排序的算法。在使用冒泡排序对长为N的数列A进行升序排序时，如果相邻两个数中左边的数大于了右边的数，则交换这两个数的位置。每次从数列的前端开始扫描，当A<sub>i</sub>＞A<sub>i+1</sub>(i=1,2,...,N-1)，就将这两个数交换。扫描进行N-1次后，数列就一定满足升序排列。
对数列A进行冒泡排序的交换次数表示：对数列A进行以上所述算法时，整数被交换的次数。（冒泡排序的算法和实现包括循环顺序、范围和终止条件等。有时会存在细微差别。 但是，当应用于相同的数列时，整数的交换次数不会因这些情况的不同而改变。）
例如，以下为对长为N的整数数列A进行冒泡排序的程序（C 语言）。
    void bubble_sort(int *a, int n) {
        int i, j;
        for (i = 0; i < n - 1; ++i) {
            for (j = 0; j < n - 1; ++j) {
                if (a[j] > a[j + 1]) {
                    /* 以下 3 行相当于一次整数交换 */
                    int x = a[j];
                    a[j] = a[j + 1];
                    a[j + 1] = x;
                }
            }
        }
    }
任务：
给出长为N的数列A，对数列A中任意两个整数进行一次交换得到数列A'。请编写程序求出对数列A'使用冒泡排序使其升序排列的交换次数的最小值。（请注意：开始时对数列A中整数的交换并不需要交换相邻两个数。）
### 输入描述
第一行为一个整数N，表示数列A的长度；
接下来的N行中的第i行(1≤i≤N)为一个整数A<sub>i</sub>，表示数列A中第i个整数。
数据范围：
1≤N≤10<sup>5</sup>
1≤A<sub>i</sub>≤10<sup>9</sup>
### 输出描述
```
输出一行一个整数：表示对数列A'进行冒泡排序的交换次数的最小值。
```
### 测试样例
#### 样例1: 输入-输出-解释
```
5
10
3
6
8
1
```
```
0
```
```
将数列A开头的10和最后的1交换，数列A'就已经是升序的了。冒泡排序的交换次数为0。
```
#### 样例2: 输入-输出-解释
```
5
3
1
7
9
5
```
```
2
```
```
将数列A第3个数7和最后一个数5交换，数列A'就成了3,1,5,9,7。A'的冒泡排序交换次数为2。
```
### 题目来源  
`JOI`"
分数到小数_1578047845852,"## 题目描述
<p>给定两个整数，分别表示分数的分子&nbsp;numerator 和分母 denominator，以字符串形式返回小数。</p>
<p>如果小数部分为循环小数，则将循环的部分括在括号内。</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> numerator = 1, denominator = 2
<strong>输出:</strong> ""0.5""
</pre>
<p><strong>示例&nbsp;2:</strong></p>
<pre><strong>输入:</strong> numerator = 2, denominator = 1
<strong>输出:</strong> ""2""</pre>
<p><strong>示例&nbsp;3:</strong></p>
<pre><strong>输入:</strong> numerator = 2, denominator = 3
<strong>输出: </strong>""0.(6)""
</pre>"
判断子序列_1580541391026,"### 题目描述
<p>给定字符串 <strong>s</strong> 和 <strong>t</strong> ，判断 <strong>s</strong> 是否为 <strong>t</strong> 的子序列。</p>
<p>你可以认为 <strong>s</strong> 和 <strong>t</strong> 中仅包含英文小写字母。字符串 <strong>t</strong> 可能会很长（长度 ~= 500,000），而 <strong>s</strong> 是个短字符串（长度 &lt;=100）。</p>
<p>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，<code>""ace""</code>是<code>""abcde""</code>的一个子序列，而<code>""aec""</code>不是）。</p>
<p><strong>示例&nbsp;1:</strong><br>
<strong>s</strong> = <code>""abc""</code>, <strong>t</strong> = <code>""ahbgdc""</code></p>
<p>返回&nbsp;<code>true</code>.</p>
<p><strong>示例&nbsp;2:</strong><br>
<strong>s</strong> = <code>""axc""</code>, <strong>t</strong> = <code>""ahbgdc""</code></p>
<p>返回&nbsp;<code>false</code>.</p>
<p><strong>后续挑战</strong> <strong>:</strong></p>
<p>如果有大量输入的 S，称作S1, S2, ... , Sk 其中 k &gt;= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？</p>
<p><strong>致谢:</strong></p>
<p>特别感谢<strong> </strong><a href=""https://leetcode.com/pbrother/"">@pbrother&nbsp;</a>添加此问题并且创建所有测试用例。</p>
### 样例输入<br>
```
abc
ahbgdc
```
### 样例输出<br>
```
True
```
### 题目来源  
`LeetCode`"
剩下的树_1580095104872,"### 题目描述
有一个长度为整数L(1<=L<=10000)的马路，可以想象成数轴上长度为L的一个线段，起点是坐标原点，在每个整数坐标点有一棵树，即在0,1,2，...，L共L+1个位置上有L+1棵树。     现在要移走一些树，移走的树的区间用一对数字表示，如 100 200表示移走从100到200之间（包括端点）所有的树。     可能有M(1<=M<=100)个区间，区间之间可能有重叠。现在要求移走所有区间的树之后剩下的树的个数。
### 输入描述
```
    两个整数L(1<=L<=10000)和M(1<=M<=100)。
    接下来有M组整数，每组有一对数字。
```
### 输出描述
```
可能有多组输入数据，对于每组输入数据，输出一个数，表示移走所有区间的树之后剩下的树的个数。
```
### 测试样例
#### 样例1:输入-输出-解释
```
500 3
100 200
150 300
470 471
```
```
298
```
```
无
```
### 题目来源  
`newcoder.com`"
加分二叉树_1580380851328,"### 题目描述
设一个n个节点的二叉树tree的中序遍历为（1，2，3，...，n)，其中数字1，2，3，...，n为节点编号。每个节点都有一个分数（均为正整数），记第i个节点的分数为di,tree及它的每个子树都有一个加分，任一棵子树subtree（也包含tree本身）的加分计算方法如下：
subtree的左子树的加分×subtree的右子树的加分＋subtree的根的分数。
若某个子树为空，规定其加分为1，叶子的加分就是叶节点本身的分数。不考虑它的空子树。
试求一棵符合中序遍历为（1,2,3,…,n1）且加分最高的二叉树tree。要求输出；
（1）tree的最高加分
（2）tree的前序遍历
### 输入描述
```
第1行：1个整数n(n<30)，为节点个数。
第2行：n个用空格隔开的整数，为每个节点的分数（分数<100）。
```
### 输出描述
```
第1行：1个整数，为最高加分（Ans0≤4,000,000,000）。
第2行：n个用空格隔开的整数，为该树的前序遍历。
```
### 测试样例
#### 样例1:输入-输出-解释
```
5
5 7 1 2 10
```
```
145
3 1 2 4 5
```
```
无
```
### 题目来源  
`luogu.com.cn`"
包含K个的子字符串的计数_1580741312784,"### 题目描述
给定一个二进制字符串和一个整数K，任务是计算精确包含K个子字符串的子字符串的数量。
### 输入描述
输入的第一行包含一个整数T，表示测试用例的数量。然后是T测试用例。每个测试用例包含一个二进制字符串和一个整数K。
### 输出描述
对于每个测试用例，在新行中打印子字符串的计数。
### 输入范例
```
2
10010 1
100101 2
```
### 输出范例
```
9
5
```
### 题目来源
geeksforgeeks.org
"
区分所有子字符串的最小更改_1577866310437,"### 题目描述
给定一个字符串s，找到对它所需的最小更改数，以便该字符串的所有子字符串变得不同。
### 输入描述
> 第一行包含一个整数`T`，为测试用例的数量。对于每个测试用例，只有包含至多 26个字符的一行。
### 输出描述
> 对于新一行中的每个测试用例，打印对该字符串的最小更改数。
### 测试样例
样例1：输入-输出-解释
```
3
aab
aebaecedabbee
ab
```
```
1
8
0
```
### 数据范围与提示
> 1 <= T <= 100
>
> 字符串长度不超过26
## 题目来源
geeksforgeeks.org"
单词分类_1581144899702,"### 题目描述
Oliver为了学好英语决定苦背单词，但很快他发现要直接记住杂乱无章的单词非常困难，他决定对单词进行分类。
两个单词可以分为一类当且仅当组成这两个单词的各个字母的数量均相等。
例如“AABAC”，它和“CBAAA”就可以归为一类，而和“AAABB”就不是一类。
现在Oliver有N个单词，所有单词均由大写字母组成，每个单词的长度不超过100。你要告诉Oliver这些单词会被分成几类。
### 输入描述
```
输入文件的第一行为单词个数N，以下N行每行为一个单词。
```
### 输出描述
```
输出文件仅包含一个数，表示这N个单词分成的类数
```
### 测试样例
#### 样例1:输入-输出-解释
```
3 
AABAC 
CBAAA 
AAABB
```
```
2
```
```
无
```
### 题目来源  
`luogu.com.cn`"
卡旋转_1578140347213,"## 题目描述
给定一张从1到N的卡片组。 1）我们拿起1张卡，并将其放在卡座的背面。 2）现在，我们拿起另一张卡，结果是编号为1的卡，我们将其放置在牌组外部。 3）现在，我们拿起2张卡片并将其放在卡座的背面。 4）现在，我们拿起另一张卡，结果是编号为2的卡，然后将其放置在牌组外部。 ... 我们执行此步骤直到最后一张卡。 如果这种布置是可能的，则输出该布置，如果N的特定值不可能，则输出-1。
## 输入描述
输入的第一行包含测试用例'T'的数量，之后是'T'测试用例。 测试用例的每一行由包含整数“ N”的一行组成。1 <= T <= 100;
1<= N<= 1000; 
## 输出描述
如果这种布置是可能的，则输出该布置，如果n的特定值不可能，则输出-1。
## 样例输入
2
4
5
## 样例输出
2 1 4 3
3 1 4 5 2
## 题目来源
geeksforgeeks.org"
卢卡斯数_1580708253148,"### 题目描述
卢卡斯数是一个由以下重复表示的数 
Ln = Ln-1 + Ln-2，n> 1 
L0 = 2 
L1 = 1 
现在给定一个数字n，您的任务是找到第n个lucas数字。 
注意：由于输出可能很长，因此请使用mod 1000000007
### 输入描述
输入的第一行包含一个整数T，表示测试用例的数量。然后是T测试用例。每行包含一个整数n。
### 输出描述
对于每个测试用例，在新行中打印第n个lucas数。
### 输入范例
```
2
9
3
```
### 输出范例
```
76
4
```
### 题目来源
geeksforgeeks.org
"
反色游戏_1578066842899,"### 题目描述
小C和小G经常在一起研究搏弈论问题，有一天他们想到了这样一个游戏.
有一个n个点m条边的无向图，初始时每个节点有一个颜色，要么是黑色，要么是白色．现在他们对于每条边做出一次抉择：要么将这条边连接的两个节点都反色（黑变白，白变黑），要么不作处理．他们想把所有节点都变为白色，他们想知道在2^m种决策中，有多少种方案能达成这个目标．
小G认为这个问题太水了，于是他还想知道，对于第i个点，在删去这个点及与它相连的边后，新的答案是多少．
由于答案可能很大，你只需要输出答案对10^9 + 7取模后的结果．
### 输入描述
```
第一行一个整数T，表示数据组数。
每组数据第一行两个整数n, m ,表示点数和边数。
接下来m行，每行两个整数u, v,描述无向图的一条边。
接下来一行一个长度为n的0/1串,如果第i个字符为0表示第i个点为白色，否则为黑色。
数据范围：
对于所有数据，有1≤T≤5, 1≤n, m≤10^5, 1≤u, v≤n，没有重边和自环。
```
### 输出描述
```
每组数据输出一行n+1个整数，第一个整数表示不删去任何点时的答案．接下来n个整数，第i个表示删去第i个点时的答案.
```
### 测试样例
#### 样例1:输入-输出-解释
```
2
5 5
1 2
2 3
3 4
2 4
3 5
00000
5 4
1 2
2 3
2 4
2 5
11111
```
```
2 2 1 1 1 2
0 1 0 1 1 1
```
```
第一组数据，在不删掉任何点时，有两种方案：要么对所有的边都不做操作；要么对(2,3),(3,4),(2,4)做操作。
在删掉2号点或3号点或4号点时，唯一的方案是对所有边都不做操作．注意图可能不连通．
```"
反转K个组元素_1580211252657,"### 题目描述
给定大小为N的正整数数组arr []。反转K个组元素的每个子数组。
### 输入描述
输入的第一行包含一个整数T，表示测试用例的数量。然后是T测试用例。每个测试用例由两行输入组成。每个测试用例的第一行包含一个整数N（数组大小）和一个整数K，中间用空格隔开。每个测试用例的第二行包含N个以空格分隔的整数，表示数组元素。
### 输出描述
对于每个测试用例，请打印修改后的数组
### 输入范例
```
2
5 3
1 2 3 4 5
6 2
10 20 30 40 50 60
```
### 输出范例
```
3 2 1 5 4
20 10 40 30 60 50
```
### 题目来源
geeksforgeeks.org
"
另一个数组的数组子集_1580436211204,"### 题目描述
给定两个数组：大小为m的arr1 [0..m-1]和大小为n的arr2 [0..n-1]。任务是检查arr2 []是否是arr1 []的子集。这两个数组都可以不排序或排序。可以假定两个数组中的元素都是不同的。
### 输入描述
输入的第一行包含一个整数T，表示测试用例的数量。然后是T测试用例。每个测试用例包含两个整数m和n，分别表示arr1和arr2的大小。以下两行分别包含以空格分隔的arr1和arr2元素。
### 输出描述
如果arr2是arr1的子集，则打印“Yes”（不带引号）。 如果arr2不是arr1的子集，则打印“No”（不带引号）。
### 输入范例
```
3
6 4
11 1 13 21 3 7
11 3 7 1
6 3
1 2 3 4 5 6
1 2 4
5 3
10 5 2 23 19
19 5 3
```
### 输出范例
```
Yes
Yes
No
```
### 题目来源
geeksforgeeks.org
"
可怜的小猪_1578123873409,"## 题目描述
<p>有 1000 只水桶，其中有且只有一桶装的含有毒药，其余装的都是水。它们从外观看起来都一样。如果小猪喝了毒药，它会在 15 分钟内死去。</p>
<p>问题来了，如果需要你在一小时内，弄清楚哪只水桶含有毒药，你最少需要多少只猪？</p>
<p>回答这个问题，并为下列的进阶问题编写一个通用算法。</p>
<p>&nbsp;</p>
<p><strong>进阶: </strong></p>
<p>假设有 <code>n</code> 只水桶，猪饮水中毒后会在 <code>m</code> 分钟内死亡，你需要多少猪（<code>x</code>）就能在 <code>p</code> 分钟内找出 “<strong>有毒</strong>” 水桶？这&nbsp;<code>n</code> 只水桶里有且仅有一只有毒的桶。</p>
<p>&nbsp;</p>
<p>输入：buckets = 1000， minutesToDie = 15，minutesToTest = 60 </p>
<p>输出：5 </p>
<p><strong>提示：</strong></p>
<ol>
	<li>可以允许小猪同时饮用任意数量的桶中的水，并且该过程不需要时间。</li>
	<li>小猪喝完水后，必须有 <em>m</em> 分钟的<strong>冷却时间</strong>。在这段时间里，只允许观察，而不允许继续饮水。</li>
	<li>任何给定的桶都可以无限次采样（无限数量的猪）。</li>
</ol>"
号码不足_1578289878596,"## 题目描述
给定数字x，您的任务是查找此数字是否为不足数字。如果由divisorsSum（x）表示的数字的所有除数的总和小于数字x的值的两倍，则将数字x称为不足数。这两个值之间的差异称为缺陷。 从数学上讲，如果满足以下条件，则该数字称为“deficiency”：
从数学上讲，如果满足以下条件，则该数字称为“不足”：
divisorsSum(x) < 2*x
deficiency = (2*x) - divisorsSum(x)
## 输入输出描述
Input: 21
Output: 1
除数分别为1、3、7和21。除数之和为32。该总和小于2 * 21或42。
Input: 12
Output: 0
Input: 17
Output: 1
## 样例输入
3
21
12
17
## 样例输出
1
0
1
## 题目来源
geeksforgeeks.org"
各位相加_1578051032564,"## 题目描述
<p>给定一个非负整数 <code>num</code>，反复将各个位上的数字相加，直到结果为一位数。</p>
<p><strong>示例:</strong></p>
<pre><strong>输入:</strong> <code>38</code>
<strong>输出:</strong> 2 
<strong>解释: </strong>各位相加的过程为<strong>：</strong><code>3 + 8 = 11</code>, <code>1 + 1 = 2</code>。 由于&nbsp;<code>2</code> 是一位数，所以返回 2。
</pre>
<p><strong>进阶:</strong><br>
你可以不使用循环或者递归，且在 O(1) 时间复杂度内解决这个问题吗？</p>"
合并K个排序数组_1580565261018,"### 题目描述
合并 k 个排序数组，返回合并后的排序数组。
### 输入描述
```
k 个排序数组
```
### 输出描述
```
返回合并后的排序数组
```
### 测试样例
#### 样例1: 输入-输出-解释
```
[[1,4,5],[1,3,4][2,6]]
```
```
[1,1,2,3,4,4,5,6]
```
### 题目来源  
`LeetCode`"
合并时没有多余的空间_1580210956158,"### 题目描述
给定两个排序的数组arr1 []和arr2 []，它们的大小为n和m，并且不递减。
任务是将两个排序后的数组合并为一个排序后的数组（以非降序排列）。 
注意：预期的时间复杂度为O（（n + m）log（n + m））。请勿使用多余的空间。
我们需要如下修改现有的数组。
```
Input: arr1[] = {10};
       arr2[] = {2, 3};
Output: arr1[] = {2}
        arr2[] = {3, 10}  
Input: arr1[] = {1, 5, 9, 10, 15, 20};
       arr2[] = {2, 3, 8, 13};
Output: arr1[] = {1, 2, 3, 5, 8, 9}
        arr2[] = {10, 13, 15, 20} 
```
### 输入描述
第一行包含一个整数T，表示测试用例的数量。每个测试用例的第一行包含两个以空格分隔的整数X和Y，表示两个排序数组的大小。每个测试用例的第二行包含X个空格分隔的整数，表示第一个排序数组P.每个测试用例的第三行包含Y个空格分隔的整数，表示第二个数组Q.
### 输出描述
对于每个测试用例，请打印（X + Y）以空格分隔的表示合并数组的整数。
### 输入范例
```
2
4 5
1 3 5 7
0 2 6 8 9
2 3
10 12
5 18 20
```
### 输出范例
```
0 1 2 3 5 6 7 8 9
5 10 12 18 20
```
### 题目来源
geeksforgeeks.org
"
后继节点_1580191919549,"### 题目描述
二叉树中一个节点的后继节点指的是，二叉树的中序遍历的序列中的下一个节点。
### 输入描述
```
第一行输入两个整数 n 和 root，n 表示二叉树的总节点个数，root 表示二叉树的根节点。
以下 n 行每行四个整数 fa，lch，rch，表示 fa 的左儿子为 lch，右儿子为 rch。(如果 lch 为 0 则表示 fa 没有左儿子，rch同理)
最后一行输入要询问的节点 node。
```
### 输出描述
```
输出一个整数表示答案。(如果 node 是最后一个节点，则输出 0 )
```
### 测试样例
#### 样例1:输入-输出-解释
```
10 6
6 3 9
3 1 4
1 0 2
2 0 0
4 0 5
5 0 0
9 8 10
10 0 0
8 7 0
7 0 0
10
```
```
a b c d
```
```
0
```
### 题目来源  
`nowcoder.com`"
后缀排序_1578238097987,"### 题目描述
读入一个长度为n的由大小写英文字母或数字组成的字符串，请把这个字符串的所有非空后缀按字典序从小到大排序，然后按顺序输出后缀的第一个字符在原串中的位置。位置编号为1到n。
### 输入描述
```
一行一个长度为n的仅包含大小写英文字母或数字的字符串。
数据范围：1≤n≤10^6
```
### 输出描述
```
第一行n个整数，第i个整数为SA[i]。
```
### 测试样例
#### 样例1:输入-输出-解释
```
ababa
```
```
5 3 1 4 2
```"
后缀表达的评估_1578222987145,"## 题目描述
给定后缀表达式，任务是评估表达式并打印最终值。运算符将仅包括基本算术运算符，例如*，/，+和-。
## 输入描述
输入的第一行将包含一个整数T，表示测试用例的数量。然后是T测试用例。每个测试用例都包含一个后缀表达式。1 <= T <= 100；1 <= 表达式长度 <= 100
## 输出描述
对于每个测试用例，请在新行中评估后缀表达式并打印该值。
## 样例输入
2
231*+9-
123+*8-
## 样例输出
-4
-3
## 题目来源
geeksforgeeks.org"
后缀转中缀_1578227554409,"## 题目描述
以字符串str的形式给出一个中缀表达式。将此中缀表达式转换为后缀表达式。
## 输入描述
输入的第一行包含一个整数T，它表示测试用例的数量。接下来的T行包含一个中缀表达式。该表达式包含所有字符和^，*，/，+，-。1 <= T <= 100；1 <= str长度 <= 10^3
## 输出描述
对于每个测试用例，在新行中将中缀表达式输出为后缀表达式。
## 样例输入
2
a+b*(c^d-e)^(f+g*h)-i
A*(B+C)/D
## 样例输出
abcd^e-fgh*+^*+i-
ABC+*D/
## 题目来源
geeksforgeeks.org"
哈夫曼树_1580100517952,"### 题目描述
哈夫曼树，第一行输入一个数n，表示叶结点的个数。需要用这些叶结点生成哈夫曼树，根据哈夫曼树的概念，这些结点有权值，即weight，题目需要输出所有结点的值与权值的乘积之和。
### 输入描述
```
输入有多组数据。
每组第一行输入一个数n，接着输入n个叶节点（叶节点权值不超过100，2<=n<=1000）。
```
### 输出描述
```
输出权值。
```
### 测试样例
#### 样例1:输入-输出-解释
```
5  
1 2 2 5 9
```
```
37
```
```
无
```
### 题目来源  
`nowcoder.com`"
四元素_1580295765729,"### 题目描述
给定一个由N个整数组成的数组A，请在数组中找到四个元素的组合，其总和等于给定值X.
### 输入描述
第一行包含T个测试用例。每个测试用例的第一行都由整数N组成，表示数组中元素的数量。第二行由N个间隔的数组元素组成。每个测试用例X的第三行。
### 输出描述
单行输出，如果找到组合则输出1，否则输出0。
### 输入范例
```
1
6
1 5 1 0 6 0
7
```
### 输出范例
```
1
```
### 题目来源
geeksforgeeks.org
"
回文数_1577681657900,"## 题目描述
判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。
## 输入描述
整数
# 输出描述
True or False
## 样例输入
121
## 样例输出
True
"
困雨水_1580210588017,"### 题目描述
给定一个由N个非负整数组成的数组arr []，将索引i处的块的高度表示为Ai，其中每个块的宽度为1.计算下雨后可以在块之间捕获多少水。
### 输入描述
输入的第一行包含一个整数T，表示测试用例的数量。 T测试用例的描述如下。每个测试用例均包含一个表示数组大小的整数N，然后是要存储在数组中的N个空格分隔的数字。
### 输出描述
输出困在块之间的水的总单位。
### 输入范例
```
2
4
7 4 0 9
3
6 9 9
```
### 输出范例
```
10
0
```
### 题目来源
geeksforgeeks.org
"
图论-信息传递_1578042452221,"### 题目描述
有n个同学（编号为1到n）正在玩一个信息传递的游戏。在游戏里每人都有一个固定的信息传递对象，其中，编号为i的同学的信息传递对象是编号为Ti的同学。游戏开始时，每人都只知道自己的生日。之后每一轮中，所有人会同时将自己当前所知的生日信息告诉各自的信息传递对象（注意：可能有人可以从若干人那里获取信息，但是每人只会把信息告诉一个人，即自己的信息传递对象）。当有人从别人口中得知自己的生日时，游戏结束。请问该游戏一共可以进行几轮？
### 输入描述
```
输入共2行。
第1行包含1个正整数n,表示n个人。
第2行包含n个用空格隔开的正整数T1, T2.....Tn，其中第Ti个整数表示编号为i的同学的信息传递对象是编号为Ti的同学, Ti < n且Ti ≠ i。
数据保证游戏一定会结束。
数据范围：
对于30%的数据，n ≤ 200;
对于60%的数据，n ≤ 2500;
对于100%的数据，n ≤ 200000。
```
### 输出描述
```
输出共l行，包含l个整数，表示游戏一共可以进行多少轮。
```
### 测试样例
#### 样例1:输入-输出-解释
```
5
2 4 2 3 1
```
```
3
```"
图论-子集_1577951232283,"### 题目描述
一个可重集合中包含n个元素a_1(符号""_""表示下标), a_2,……，a_n,你需要选择一个子集, 使得这个子集中任意两个元素a_i, a_j 均满足条件gcd(a_i,a_j)gcd(a_i + 1,a_j + 1) ≠ 1，且这个子集的
元素个数是所有满足上述条件的子集中最多的。输出这个子集的元素个数。
### 输入描述
```
输入的第一行包含一个正整数n。
随后n行，每行一个正整数a_i。
数据范围 1<=n<=500，1<=a_i<=10^18
```
### 输出描述
```
输出一个整数代表符合条件的元素最多的子集的元素个数。
```
### 测试样例
#### 样例1:输入-输出-解释
```
3
4
6
9
```
```
3
```"
图论-最小树形图_1577912182462,"### 题目描述
给定包含n个结点，m条有向边的一个图。试求一棵以结点r为根的最小树形图,并输出最小树形图每条边的权值之和,如果没有以r为根的最小树形图，输出-1。
### 输入描述
```
第一行包含三个整数n,m,r,意义同题目所述。
接下来m行，每行包含三个整数u, v, w,表示图中存在一从u指向V的权值为w的有向边。
对于所有数据，1≤u,v≤n≤100,1≤m≤10^4,1≤w≤10^6。
```
### 输出描述
```
如果原图中存在以r为根的最小树形图,就输出最小树形图每条边的权值之和，否则输出-1。
```
### 测试样例
#### 样例1:输入-输出-解释
```
4 6 1
1 2 3
1 3 1
4 1 2
4 2 2
3 2 1
3 4 1
```
```
3
```
```
最小树形图中包含第2，5，6三边,总权值为1+1+1=3
```
#### 样例2:输入-输出-解释
```
4 6 3
1 2 3
1 3 1
4 1 2
4 2 2
3 2 1
3 4 1
```
```
4
```
```
最小树形图中包含第3，5，6三边,总权值为2+1+1=4
```
#### 样例3:输入-输出-解释
```
4 6 2
1 2 3
1 3 1
4 1 2
4 2 2
3 2 1
3 4 1
```
```
-1
```
```
无法构成最小树形图，故输出-1。
```"
图论-最小生成树_1577949397932,"### 题目描述
给定结点数为n,边数为m的带权无向连通图G,所有结点编号为1,2,...,n。
求G的最小生成树的边权和。
### 输入描述
```
第一行两个正整数n, m。
之后的m行,每行三个正整数u_i(符号""_""表示下标),v_i,w_i(1≤u_i,v_i≤n, 0≤w_i≤10^9), 描述一条连接结点u_i和v_i,边权为w_i的边。
其中 1≤n≤2x10^5，0≤m≤5x10^5。
```
### 输出描述
```
一个整数表示G的最小生成树的边权和。
```
### 测试样例
#### 样例1:输入-输出-解释
```
7 12
1 2 9
1 5 2
1 6 3
2 3 5
2 6 7
3 4 6
3 7 3
4 5 6
4 7 2
5 6 3
5 7 6
6 7 1
```
```
16
```"
图论-最短路径树问题_1578031111112,"### 题目描述
给一个包含n个点，m条边的无向连通图。从顶点1出发，往其余所有点分别走一次并返回。
往某一个点走时，选择总长度最短的路径走。若有多条长度最短的路径，则选择经过的顶点序列字典序最小的那条路径（如路径A为1，32，11，路径B为1，3，2，11，路径B字典序较小。注意是序列的字典序的最小，而非路径中节点编号相连的字符串字典序最小）。到达该点后按原路返回，然后往其他点走，直到所有点都走过。
可以知道，经过的边会构成一棵最短路径树。请问，在这棵最短路径树上，最长的包含k个点的简单路径长度为多长？长度为该最长长度的不同路径有多少条？
这里的简单路径是指：对于一个点最多只经过一次的路径。不同路径是指路径两端端点至少有一个不同，点A到点B的路径和点B到点A视为同一条路径。
### 输入描述
```
第一行输入三个正整数n,m,k,表示有n个点m条边,要求的路径需要经过k个点。
接下来输入m行，每行三个正整数Ai,Bi,Ci (1≤Ai,Bi≤n,1≤Ci≤10000)，表示Ai和Bi间有一条长度为Ci的边。数据保证输入的是连通的无向图。
数据范围：对于所有数据,n≤30000,m≤60000,2≤k≤n。
数据保证最短路径树上至少存在一条长度为k的路径。
```
### 输出描述
```
输出一行两个整数，以一个空格隔开，第一个整数表示包含k个点的路径最长为多长，第二个整数表示这样的不同的最长路径有多少条。
```
### 测试样例
#### 样例1:输入-输出-解释
```
6 6 4
1 2 1
2 3 1
3 4 1
2 5 1
3 6 1
5 6 1
```
```
3 4
```"
图论-求和_1578049734380,"### 题目描述
master 对树上的求和非常感兴趣。他生成了一棵有根树，并且希望多次询问这棵树上一段路径上所有节点深度的k次方和，而且每次的k可能是不同的。此处节点深度的定义是这个节点到根的路径上的边数。 他把这个问题交给了 pupil，但 pupil 并不会这么复杂的操作，你能帮他解决吗？
### 输入描述
```
第一行包含一个正整数 n,表示树的节点数。
之后n- 1行每行两个空格隔开的正整数i,j,表示树上的一条连接点i和点j的边。
之后一行一个正整数m,表示询问的数量。
之后每行三个空格隔开的正整数i,j,k,表示询问从点i到点j的路径上所有节点深度的k次方和。由于这个结果可能非常大，输出其对998244353取模的结果。
树的节点从1开始标号，其中1号节点为树的根。
数据范围：
对于30%的数据，1≤n,m≤100;
对于60%的数据，1≤n,m≤1000;
对于100%的数据，1≤n,m≤300000,1≤k≤50。
```
### 输出描述
```
对于每组数据输出一行一个正整数表示取模后的结果。
```
### 测试样例
#### 样例1:输入-输出-解释
```
5
1 2
1 3
2 4
2 5
2
1 4 5
5 4 45
```
```
33
503245989
```
```
以下用d(i)表示第i个节点的深度。
对于样例中的树，有d(1)=0,d(2)= 1,d(3)= 1,d(4)=2,d(5)= 2。
因此第一个询问答案为(2^5 + 1^5 + 0^5) mod 998244353 = 33,第二个询问答案为(2^45 + 1^45 + 2^45) mod 998244353 = 503245989。
```"
图论-网络_1578038135945,"### 题目描述
一个一般的网络系统可以被描述成一张无向连通图。图上每个节点为一个服务器，连接服务器与服务器的数据线则看作图上的一条边，边权为该数据线的长度。两个服务器之间的通讯距离定义为其对应节点之间的最短路长度。
现在，考虑一个当前图结构为树的网络系统。你作为该网络系统的管理员，被要求在这个系统中加入一条给定长度的数据线。数据线可以连在任意两个服务器上。
你的任务是，求出在所有合法的方案中，通讯距离最远的两个服务器之间的最小距离。
### 输入描述
```
输入包含多组数据。对于每组数据，输入的第一行包含两个正整数n, L,其中n表示服务器个数, L为新加入的数据线的长度。
接下来n- 1行，第i行有三个正整数a_i(符号""_""表示下标),b_i,l_i,表示有一条长度为l_i的数据线连接服务器a_i, b_i。服务器编号为1 ~ n。
输入的末尾以两个0作为结束。
数据范围：
一共有20个测试点，编号为1 ~ 20。每个测试点为5分。
保证在任一测试点中, 数据的组数不会超过15,且所有数据的n之和不超过数据范围中标明的n的最大值的5倍。
保证所有的输入数据均为不超过2^31 - 1的非负整数,保证n≥1。
保证数据合法。
测试点1: n ≤ 10;
测试点2: n ≤ 50;
测试点3~4: n ≤ 100;
测试点5: n ≤ 150;
测试点6~8: n ≤ 600;
测试点9~10: n ≤ 2000; .
测试点11~ 15: n ≤ 20000;
测试点16~20: n ≤ 100000;
```
### 输出描述
```
对于每组数据，输出一行一个整数，描述在所有合法的方案中，通讯距离最远的两个服务器之间的最小距离。
```
### 测试样例
#### 样例1:输入-输出-解释
```
7 1
1 2 1
2 3 1
3 4 1
4 5 1
5 6 1
6 7 1
0 0
```
```
3
```"
图论-非负权单源最短路_1577907780571,"### 题目描述
给一个n(1<=n<=2500)个点m(1<=m<=6200)条边的无向图，求s到t的最短路。
### 输入描述
```
第一行四个由空格隔开的整数n、m、s、t。
之后的m行，每行三个正整数s_i（符号“_”表示下标）、t_i、w_i(1<=W_i<=10^9)，表示一条从s_i到t_i长度为w_i的边。
```
### 输出描述
```
一个整数表示从s到t的最短路长度。数据保证至少存在一条道路。
```
### 测试样例
#### 样例1:输入-输出-解释
```
7 11 5 4
2 4 2
1 4 3
7 2 2
3 4 3
5 7 5
7 3 3
6 1 1
6 3 4
2 4 3
5 6 3
7 2 1
```
```
7
```"
图论-黑暗前的幻想乡_1577955445107,"### 题目描述
四年一度的幻想乡大选开始了，最近幻想乡最大的问题是很多来历不明的妖怪涌入了幻想乡，扰乱了幻想乡昔日的秩序。但是幻想乡的建制派妖怪（人类）博丽灵梦和八云紫等人整日高谈所有妖怪平等，幻想乡多元化等等，对于幻想乡目前面临的种种大问题却给不出合理的解决方案。
风见幽香是幻想乡里少有的意识到了问题严重性的大妖怪。她这次勇敢地站了出来参加幻想乡大选，提出包括在幻想乡边境建墙（并让人类出钱），大力开展基础设施建设挽回失业率等一系列方案，成为了大选年出人意料的黑马并顺利地当上了幻想乡的大统领。
幽香上台以后，第一项措施就是要修建幻想乡的公路。幻想乡一共有n个城市，之前原来没有任何路。幽香向选民承诺要减税，所以她打算只修n-1条公路将这些城市连接起来。但是幻想乡有正好n-1个建筑公司，每个建筑公司都想在修路地过程中获得一些好处。虽然这些建筑公司在选举前没有给幽香钱，幽香还是打算和他们搞好关系，因为她还指望他们帮她建墙。所以她打算让每个建筑公司都负责一条路来修。
每个建筑公司都告诉了幽香自己有能力负责修建的路是哪些城市之间的。所以幽香打算n-1条能够连接幻想乡所有城市的边，然后每条边都交给一个能够负责该边的建筑公司修建，并且每个建筑公司都恰好修建一条边。
幽香现在想要知道一共有多少种可能的方案呢？两个方案不同当且仅当它们要么修的边的集合不同，要么边的分配方式不同。
### 输入描述
```
第一行包含一个整数n，表示城市个数。
接下来n-1行，第i行表示第i个建筑公司可以修建的路的列表：以一个非负数m_i(符号""_""表示下标)开头，表示其可以修建m_i条路；接下来有m_i对数，每对数表示一条边的两个端点。其中不会出现重复的边，也不会出现自环。
数据范围  case1,2:n<=5  ;  case3~5:n<=8  ;  case6:n<=10  ;  case7~10:n<=17
```
### 输出描述
```
输出一行一个整数，表示所有可能的方案数对10^9 + 7取模的结果。
```
### 测试样例
#### 样例1:输入-输出-解释
```
4
2 3 2 4 2
5 2 1 3 1 3 2 4 1 4 3
4 2 1 3 2 4 1 4 2
```
```
17
```"
在排序数组中查找元素的第一个和最后一个位置_1580449475334,"### 题目描述
<p>给定一个按照升序排列的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。找出给定目标值在数组中的开始位置和结束位置。</p>
<p>你的算法时间复杂度必须是&nbsp;<em>O</em>(log <em>n</em>) 级别。</p>
<p>如果数组中不存在目标值，返回&nbsp;<code>[-1, -1]</code>。</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> nums = [<code>5,7,7,8,8,10]</code>, target = 8
<strong>输出:</strong> [3,4]</pre>
<p><strong>示例&nbsp;2:</strong></p>
<pre><strong>输入:</strong> nums = [<code>5,7,7,8,8,10]</code>, target = 6
<strong>输出:</strong> [-1,-1]</pre>
### 样例输入<br>
```
5,7,7,8,8,10
8
```
### 样例输出<br>
```
[3, 4]
```
### 题目来源  
`LeetCode`"
基本计算器_1578050148042,"## 题目描述
<p>实现一个基本的计算器来计算一个简单的字符串表达式的值。</p>
<p>字符串表达式可以包含左括号&nbsp;<code>(</code>&nbsp;，右括号&nbsp;<code>)</code>，加号&nbsp;<code>+</code>&nbsp;，减号&nbsp;<code>-</code>，<strong>非负</strong>整数和空格&nbsp;<code>&nbsp;</code>。</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> ""1 + 1""
<strong>输出:</strong> 2
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong> "" 2-1 + 2 ""
<strong>输出:</strong> 3</pre>
<p><strong>示例 3:</strong></p>
<pre><strong>输入:</strong> ""(1+(4+5+2)-3)+(6+8)""
<strong>输出:</strong> 23</pre>
<p><strong>说明：</strong></p>
<ul>
	<li>你可以假设所给定的表达式都是有效的。</li>
	<li>请<strong>不要</strong>使用内置的库函数 <code>eval</code>。</li>
</ul>"
多数元素_1580190831469,"### 题目描述
给定一个由N个元素组成的数组A。在数组中找到多数元素。大小为N的数组A中的多数元素是在数组中出现N / 2次以上的元素。
### 输入描述
输入的第一行包含T，表示测试用例的数量。测试用例的第一行将是数组的大小，第二行将是数组的元素。
### 输出描述
对于每个测试用例，输出将是数组的多数元素。如果数组中没有多数元素，则输出“ -1”。
### 输入范例
```
2
5
3 1 3 3 2
3
1 2 3
```
### 输出范例
```
3
-1
```
### 题目来源
geeksforgeeks.org
"
好坏字符串_1578286600212,"### 题目描述
有一个只包含小写字母，长度为n的字符串S。有一些字母是好的,剩下的是坏的。
定义一个子串S_l. . .r(这里的l,r是下标)是好的，当且仅当这个子串包含不超过k个坏的字母。
求有多少个不同的满足以下要求的字符串T :
	T作为S的子串出现过。
	存在一个T出现的位置[l,r],满足S_l...r(这里的l,r是下标)是好的。
### 输入描述
```
第一行有一个字符串S。
第二行有一个字符串B。若Bi ='1'则表示Si是好的,否则表示Si是坏的。
第三行有一个整数k。
```
### 输出描述
```
一个整数：答案。
```
### 测试样例
#### 样例1:输入-输出-解释
```
ababab
010101
1
```
```
5
```
```
所有'b'是好的，'a'是坏的。
满足条件的字符串有：""a"",""ab"",""b"",""ba"",""bab""。
```"
子串查找_1577868767370,"### 题目描述
这是一道模板题。
给定一个字符串` A`和一个字符串`  B` ，求` B` 在`  A`中的出现次数。` A` 和` B` 中的字符均为英语大写字母或小写字母。
 ` A` 中不同位置出现的` B` 可重叠。
### 输入描述
> 输入共两行，分别是字符串` A`和字符串`  B` 。
### 输出描述
> 输出一个整数，表示 ` A` 在` B` 中的出现次数。
### 测试样例
样例1：输入-输出-解释
```
zyzyzyz
zyz
```
```
3
```
### 数据范围与提示
> 1<=` A,B的长度` <=100000，` A、B` 仅包含大小写字母"
字串覆盖_1578277402756,"### 题目描述
小C对字符串颇有研究,他觉得传统的字符串匹配太无聊了，是他想到了这样一个问题。
对于两个长度为n的串A, B ,小C每次会给出给出4个参数s,t,l,r.令A从s到t的子串(从1开始标号）为T,令B从l到r的子串为P。然后他会进行下面的操作:
如果T的某个子串与P相同,我们就可以覆盖T的这个子串，并获得K - i 的收益,中i是初始时A中(注意不是T中）这个子串的起始位置，K 是给定的参数.一个位置不能被覆盖多次.覆盖操作可以进行任意多次,你需要输出获得收益的最大值.
注意每次询问都是独立的,即进行一次询问后, 覆盖的位置会复原.
### 输入描述
```
第一行两个整数n, K，表示字符串长度和参数.
接下来一行一个字符串A.
接下来一行一个字符串B.
接下来一行一个整数q，示询问个数.
接下来q行，每行四个整数s,t,l,r,表示一次询问. 
数据范围：
对于所有数据，有1≤n,q≤10^5, A, B仅由小写英文字母组成，1≤s≤t≤n, 1≤l≤r≤n, n<K≤10^9
对于n= 10^5的测试点，满足51≤r-l≤2000的询问不超过11000个,且r- l在该区间内均匀随机.
```
### 输出描述
```
输出q行，每行一个整数，表示一个询问的答案．
```
### 测试样例
#### 样例1:输入-输出-解释
```
10 11
abcbababab
ababcbabab
5
1 9 7 9
3 10 8 10
1 10 1 2
5 7 2 3
1 5 3 6
```
```
6
10
22
5
10
```
```
对于第一组询问T = abcbababa, P = aba,收益为K - 5= 6.
对于第二组询问T = cbababab, P= bab,收益为(K - 4)+(K- 8)= 10.
```"
字典树的实现_1580184504148,"### 题目描述
字典树又称为前缀树或者Trie树，是处理字符串常用的数据结构。假设组成所有单词的字符仅是‘a’～‘z’，请实现字典树的结构，并包含以下四个主要的功能。void insert(String word)：添加word，可重复添加；void delete(String word)：删除word，如果word添加过多次，仅删除一次；boolean search(String word)：查询word是否在字典树中出现过(完整的出现过，前缀式不算)；int prefixNumber(String pre)：返回以字符串pre作为前缀的单词数量。现在给定一个m，表示有m次操作，每次操作都为以上四种操作之一。每次操作会给定一个整数op和一个字符串word，op代表一个操作码，如果op为1，则代表添加word，op为2则代表删除word，op为3则代表查询word是否在字典树中，op为4代表返回以word为前缀的单词数量（数据保证不会删除不存在的word）。
### 输入描述
输入包含多行，第一行一个整数m(1≤m≤10^5)，代表操作次数。接下来m行，每行包含一个整数op(1≤op≤4)，和一个字符串word(1≤length(word)≤20)。
### 输出描述
```
对于每次操作，如果op为3时，如果word在字典树中，请输出“YES”，否则输出“NO”；如果op为4时，请输出返回以word为前缀的单词数量，其它情况不输出。
```
### 测试样例
#### 样例1:输入-输出-解释
```
7
1 qwer
1 qwe
3 qwer
4 q
2 qwer
3 qwer
4 q
```
```
YES
2
NO
1
```
```
无
```
### 题目来源  
`nowcoder.com`"
字符串_1578245780260,"### 题目描述
佳媛姐姐过生日的时候，她的小伙伴从某东上买了一个生日礼物。生日礼物放在一个神奇的箱子中。箱子外边写了一个长为n的字符串s，和m个问题。佳媛姐姐必须正确回答这m个问题，才能打开箱子拿到礼物，升职加薪，出任 CEO，嫁给高富帅，走上人生巅峰。每个问题均有a,b,c,d四个参数，问你子串s[a...b]的所有子串和s[c...d]的最长公共前缀的长度的最大值是多少？佳媛姐姐并不擅长做这样的问题，所以她向你求助，你该如何帮助她呢？
### 输入描述
```
输入的第一行有两个正整数n,m，分别表示字符串的长度和询问的个数。
接下来一行是一个长为n的字符串。字符串中仅有小写英文字母。
接下来m行，每行有四个数a,b,c,d，表示询问s[a...b]的所有子串和s[c...d]的最长公共前缀的最大值。
数据范围：对于所有的数据，1≤n, m≤100000, a≤b, c≤d, 1≤a,b,c,d≤n
```
### 输出描述
```
对于每一次询问，输出答案。
```
### 测试样例
#### 样例1:输入-输出-解释
```
5 5
aaaaa
1 1 1 5
1 5 1 1
2 3 2 3
2 4 2 3
2 3 2 4
```
```
1 
1 
2 
2 
2
```"
字符串相乘_1577687896817,"## 题目描述
<p>给定两个以字符串形式表示的非负整数&nbsp;<code>num1</code>&nbsp;和&nbsp;<code>num2</code>，返回&nbsp;<code>num1</code>&nbsp;和&nbsp;<code>num2</code>&nbsp;的乘积，它们的乘积也表示为字符串形式。</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> num1 = ""2"", num2 = ""3""
<strong>输出:</strong> ""6""</pre>
<p><strong>示例&nbsp;2:</strong></p>
<pre><strong>输入:</strong> num1 = ""123"", num2 = ""456""
<strong>输出:</strong> ""56088""</pre>
<p><strong>说明：</strong></p>
<ol>
	<li><code>num1</code>&nbsp;和&nbsp;<code>num2</code>&nbsp;的长度小于110。</li>
	<li><code>num1</code> 和&nbsp;<code>num2</code> 只包含数字&nbsp;<code>0-9</code>。</li>
	<li><code>num1</code> 和&nbsp;<code>num2</code>&nbsp;均不以零开头，除非是数字 0 本身。</li>
	<li><strong>不能使用任何标准库的大数类型（比如 BigInteger）</strong>或<strong>直接将输入转换为整数来处理</strong>。</li>
</ol>"
字符串转换整数_1577685079613,"## 题目描述
<p>请你来实现一个&nbsp;<code>atoi</code>&nbsp;函数，使其能将字符串转换成整数。</p>
<p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</p>
<p>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。<p>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</p></p>
<p>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</p>
<p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</p>
<p>在任何情况下，若函数不能进行有效的转换时，请返回 0。</p>
<p><strong>说明：</strong></p>
<p>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为&nbsp;[−2<sup>31</sup>,&nbsp; 2<sup>31&nbsp;</sup>− 1]。如果数值超过这个范围，请返回 &nbsp;INT_MAX (2<sup>31&nbsp;</sup>− 1) 或&nbsp;INT_MIN (−2<sup>31</sup>) 。</p>
<p><strong>示例&nbsp;1:</strong></p>
<pre><strong>输入:</strong> ""42""
<strong>输出:</strong> 42
</pre>
<p><strong>示例&nbsp;2:</strong></p>
<pre><strong>输入:</strong> ""   -42""
<strong>输出:</strong> -42
<strong>解释: </strong>第一个非空白字符为 '-', 它是一个负号。
&nbsp;    我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。
</pre>
<p><strong>示例&nbsp;3:</strong></p>
<pre><strong>输入:</strong> ""4193 with words""
<strong>输出:</strong> 4193
<strong>解释:</strong> 转换截止于数字 '3' ，因为它的下一个字符不为数字。
</pre>
<p><strong>示例&nbsp;4:</strong></p>
<pre><strong>输入:</strong> ""words and 987""
<strong>输出:</strong> 0
<strong>解释:</strong> 第一个非空字符是 'w', 但它不是数字或正、负号。
     因此无法执行有效的转换。</pre>
<p><strong>示例&nbsp;5:</strong></p>
<pre><strong>输入:</strong> ""-91283472332""
<strong>输出:</strong> -2147483648
<strong>解释:</strong> 数字 ""-91283472332"" 超过 32 位有符号整数范围。 
&nbsp;    因此返回 INT_MIN (−2<sup>31</sup>) 。
</pre>"
存在重复元素_1580448429544,"### 题目描述
给定一个整数数组，判断数组中是否有两个不同的索引 i 和 j，使得 nums [i] 和 nums [j] 的差的绝对值最大为 t，并且 i 和 j 之间的差的绝对值最大为 ķ。
### 输入描述
```
一个整数数组,和两个非负整数k,t。
```
### 输出描述
```
true或者false
```
### 测试样例
#### 样例1: 输入-输出-解释
```
nums = [1,2,3,1], k = 3, t = 0
```
```
true
```"
安全游戏_1578275845234,"## 题目描述
n人围成一个圈（从1到n顺时针编号）等待执行。 计数从圆中的点1开始，并沿固定方向（顺时针）围绕圆进行。 在每个步骤中，将跳过一定数量的人，然后执行下一个人。 消灭围绕圈进行（随着被处决者的撤离，圈变得越来越小），直到只有最后一个剩下的人被赋予了自由。 给定总人数n和数字k，表示跳过k-1个人并且第k个人被杀。 任务是选择初始圈子中的位置，以便您成为最后一个幸存者，从而生存下来。 考虑如果n = 5且k = 2，则安全位置为3。首先，杀死位置2的人员，然后杀死位置4的人员，然后杀死位置1的人员。 最终，位置5的人被杀死。 因此，位置3的人幸存下来。
## 输入描述
输入的第一行包含一个整数T，表示测试用例的数量。然后是T测试用例。每个测试用例的第一行也是唯一一行是由两个以n和k分隔的正整数组成。1 ≤ T ≤ 200；1 ≤ n, k ≤ 200
## 输出描述
对应于每个测试用例，在新行中打印安全位置。
## 样例输入
3
2 1
4 2
50 10
## 样例输出
2
1
36
## 题目来源
geeksforgeeks.org"
完全平方数_1578052819098,"## 题目描述
<p>给定正整数&nbsp;<em>n</em>，找到若干个完全平方数（比如&nbsp;<code>1, 4, 9, 16, ...</code>）使得它们的和等于<em> n</em>。你需要让组成和的完全平方数的个数最少。</p>
<p><strong>示例&nbsp;1:</strong></p>
<pre><strong>输入:</strong> <em>n</em> = <code>12</code>
<strong>输出:</strong> 3 
<strong>解释: </strong><code>12 = 4 + 4 + 4.</code></pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong> <em>n</em> = <code>13</code>
<strong>输出:</strong> 2
<strong>解释: </strong><code>13 = 4 + 9.</code></pre>"
对0、1和2的数组进行排序_1580044533249,"### 题目描述
给定大小为N的数组A，其中包含0、1和2；您需要按升序对数组进行排序
### 输入描述
第一行包含一个整数“ T”，表示测试用例的总数。然后是T个测试用例。每个测试用例包含两行输入。第一行表示数组N的大小。第二行包含以空格分隔的数组A的元素。
### 输出描述
对于每个测试用例，打印排序后的数组。
### 输入范例
```
2
5
0 2 1 2 0
3
0 1 0
```
### 输出范例
```
0 0 1 2 2
0 0 1
```
### 题目来源
geeksforgeeks.org
"
对链表进行插入排序_1580446182840,"### 题目描述
对链表进行插入排序。
插入排序是指，从第一个元素开始，该链表可以被认为已经部分排序。
每次迭代时，从输入数据中移除一个元素，并原地将其插入到已排好序的链表中。
插入排序算法：
1.插入排序是迭代的，每次只移动一个元素，直到所有元素可以形成一个有序的输出列表。
2.每次迭代中，插入排序只从输入数据中移除一个待排序的元素，找到它在序列中适当的位置，并将其插入。
3.重复直到所有输入数据插入完为止。
### 输入描述
```
未排序的数组
```
### 输出描述
```
排好序的数组
```
### 测试样例
#### 样例1: 输入-输出-解释
```
[4,2,1,3]
```
```
[1,2,3,4]
```"
寻找 LCT_1578201870059,"### 题目描述
定义树的重心：一个点是树的重心，当且仅当删去这个点后产生的所有连通块的节点数不超过原树节点数的1/2。也就是说，如果原树有n个节点，产生的任意连通块节点数不超过n/2。
LCT（Link-Cut Tree）：一种用于解决动态树问题的数据结构，支持两种操作：删去一条边（cut），加入一条连接两个尚未连通的点的边（link）。
你有一棵n个节点的树，现在你要交替进行k次 cut 和k次 link 操作，可以对任意一条边进行操作。你需要解决的问题是：对于每个节点，k次操作结束后它是否有可能成为新树的重心。为了重心的唯一性，保证n是奇数。
### 输入描述
```
第一行两个整数n,k，表示树的节点数和操作次数。 第二行到第n行，第i+1行两个整数u_i(符号""_""表示下标)和v_i，表示初始时有一条连接u_i和v_i 的边。
```
### 输出描述
```
输出共n行。第i行一个整数，0 表示第i个节点不可能成为重心，1 表示第i个节点可能成为重心。
```
### 测试样例
#### 样例1:输入-输出-解释
```
7 2
1 2
1 3
1 4
1 5
5 6
6 7
```
```
1
1
1
1
1
1
1
```
```
让5成为重心的一种方法:断开(1,2),连接(5,2),断开(5,2), 连接(5,2)。
让6成为重心的一种方法:断开(1,2),连接(6,2),断开(1,3), 连接(6,3)。
让7成为重心的-种方法:断开(1,2),连接(7,2),断开(5,1),连接(7,1)。
```"
寻找奇数_1580436517453,"### 题目描述
给定一个正整数数组，其中所有数字均出现偶数次，但一个数字出现奇数次。查找该数字。
### 输入描述
输入的第一行包含一个整数T，表示测试用例的数量。然后是T测试用例。每个测试用例由两行组成。每个测试用例的第一行由整数N组成，其中N是数组的大小。每个测试用例的第二行包含N个以空格分隔的整数，表示数组元素。
### 输出描述
对应于每个测试用例，打印出现奇数次的数字。如果不存在这样的元素，则打印0。
### 输入范例
```
1
5
8 4 4 8 23
```
### 输出范例
```
23
```
### 题目来源
geeksforgeeks.org
"
寻找峰值_1580453368046,"### 题目描述
<p>峰值元素是指其值大于左右相邻值的元素。</p>
<p>给定一个输入数组&nbsp;<code>nums</code>，其中 <code>nums[i] ≠ nums[i+1]</code>，找到峰值元素并返回其索引。</p>
<p>数组可能包含多个峰值，在这种情况下，返回任何一个峰值所在位置即可。</p>
<p>你可以假设&nbsp;<code>nums[-1] = nums[n] = -∞</code>。</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> <strong>nums</strong> = <code>[1,2,3,1]</code>
<strong>输出:</strong> 2
<strong>解释: </strong>3 是峰值元素，你的函数应该返回其索引 2。</pre>
<p><strong>示例&nbsp;2:</strong></p>
<pre><strong>输入:</strong> <strong>nums</strong> = <code>[</code>1,2,1,3,5,6,4]
<strong>输出:</strong> 1 或 5 
<strong>解释:</strong> 你的函数可以返回索引 1，其峰值元素为 2；
&nbsp;    或者返回索引 5， 其峰值元素为 6。
</pre>
<p><strong>说明:</strong></p>
<p>你的解法应该是&nbsp;<em>O</em>(<em>logN</em>)<em>&nbsp;</em>时间复杂度的。</p>
### 样例输入<br>
```
1,2,3,1
```
### 样例输出<br>
```
2
```
### 题目来源  
`LeetCode`"
寻找旋转排序数组中的最小值 II_1580453236052,"### 题目描述
<p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p>
<p>( 例如，数组&nbsp;<code>[0,1,2,4,5,6,7]</code> <strong> </strong>可能变为&nbsp;<code>[4,5,6,7,0,1,2]</code>&nbsp;)。</p>
<p>请找出其中最小的元素。</p>
<p>注意数组中可能存在重复的元素。</p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入:</strong> [1,3,5]
<strong>输出:</strong> 1</pre>
<p><strong>示例&nbsp;2：</strong></p>
<pre><strong>输入:</strong> [2,2,2,0,1]
<strong>输出:</strong> 0</pre>
<p><strong>说明：</strong></p>
<ul>
	<li>这道题是&nbsp;<a href=""https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/description/"">寻找旋转排序数组中的最小值</a>&nbsp;的延伸题目。</li>
	<li>允许重复会影响算法的时间复杂度吗？会如何影响，为什么？</li>
</ul>
### 样例输入<br>
```
1,3,5
```
### 样例输出<br>
```
1
```
### 题目来源  
`LeetCode`"
寻找旋转排序数组中的最小值_1580450812181,"### 题目描述
<p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p>
<p>( 例如，数组&nbsp;<code>[0,1,2,4,5,6,7]</code> <strong> </strong>可能变为&nbsp;<code>[4,5,6,7,0,1,2]</code>&nbsp;)。</p>
<p>请找出其中最小的元素。</p>
<p>你可以假设数组中不存在重复元素。</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> [3,4,5,1,2]
<strong>输出:</strong> 1</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong> [4,5,6,7,0,1,2]
<strong>输出:</strong> 0</pre>
### 样例输入<br>
```
3,4,5,1,2
```
### 样例输出<br>
```
1
```
### 题目来源  
`LeetCode`"
寻找重复数_1580538174683,"### 题目描述
<p>给定一个包含&nbsp;<em>n</em> + 1 个整数的数组&nbsp;<em>nums</em>，其数字都在 1 到 <em>n&nbsp;</em>之间（包括 1 和 <em>n</em>），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> <code>[1,3,4,2,2]</code>
<strong>输出:</strong> 2
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong> [3,1,3,4,2]
<strong>输出:</strong> 3
</pre>
<p><strong>说明：</strong></p>
<ol>
	<li><strong>不能</strong>更改原数组（假设数组是只读的）。</li>
	<li>只能使用额外的 <em>O</em>(1) 的空间。</li>
	<li>时间复杂度小于 <em>O</em>(<em>n</em><sup>2</sup>) 。</li>
	<li>数组中只有一个重复的数字，但它可能不止重复出现一次。</li>
</ol>
### 样例输入<br>
```
1,3,4,2,2
```
### 样例输出<br>
```
2
```
### 题目来源  
`LeetCode`"
将所有零移动到数组末尾_1580308584619,"### 题目描述
给定一个正整数数组A。将给定数组的所有零推到数组的末尾。
### 输入描述
第一行包含一个整数T，表示测试用例的总数。在每个测试用例中，第一行是数组N中元素的数量，下一行是数组元素。
### 输出描述
最后将全0移后打印数组。
### 输入范例
```
1
5
3 5 0 0 4
```
### 输出范例
```
3 5 4 0 0
```
### 题目来源
geeksforgeeks.org
"
局域网_1580291840631,"### 题目描述
某个局域网内有n(n<=100)台计算机，由于搭建局域网时工作人员的疏忽，现在局域网内的连接形成了回路，我们知道如果局域网形成回路那么数据将不停的在回路内传输，造成网络卡的现象。因为连接计算机的网线本身不同，所以有一些连线不是很畅通，我们用f(i,j)表示i,j之间连接的畅通程度，f(i,j)值越小表示i,j之间连接越通畅，f(i,j)为0表示i,j之间无网线连接。
需要解决回路问题，我们将除去一些连线，使得网络中没有回路，并且被除去网线的Σf(i,j)最大，请求出这个最大值。
### 输入描述
```
第一行两个正整数n k
接下来的k行每行三个正整数i j m表示i,j两台计算机之间有网线联通，通畅程度为m。
```
### 输出描述
```
一个正整数，Σf(i,j)的最大值
```
### 测试样例
#### 样例1:输入-输出-解释
```
5 5
1 2 8
1 3 1
1 5 3
2 4 5
3 4 2
```
```
8
```
```
无
```
### 题目来源  
`luogu.com.cn`"
局部排序_1580299140510,"### 题目描述
在 2016 年，佳媛姐姐喜欢上了数字序列。因而他经常研究关于序列的一些奇奇怪怪的问题，现在他在研究一个难题，需要你来帮助他。
这个难题是这样子的：给出一个1到n的全排列，现在对这个全排列序列进行m次局部排序，排序分为两种：
1.(0,l,r)表示将区间[l,r]的数字升序排序
2.(1,l,r)表示将区间[l,r]的数字降序排序
排序后询问第q位置上的数字。
### 输入描述
```
输入数据的第一行为两个整数 n和m。n表示序列的长度, m表示局部排序的次数(1≤n,m≤10^5)。
第二行为n个整数,表示1到n的一个全排列。
接下来输入m行，每一行有三个整数op,l,r, op 为0代表升序排序，op为1代表降序排序, l, r表示排序的区间。
最后输入一个整数q，q表示排序完之后询问的位置，1≤q≤n。
```
### 输出描述
```
输出数据仅有一行，一个整数，表示按照顺序将全部的部分排序结束后第q位置上的数字。
```
### 测试样例
#### 样例1:输入-输出-解释
```
6 3
1 6 2 5 3 4
0 1 4
1 3 6
0 2 4
3
```
```
5
```
### 题目来源  
`TJOI / HEOI`"
左侧较小而右侧较大的元素_1580280620990,"### 题目描述
给定大小为N的未排序数组。找到数组中的第一个元素，使其所有左元素都较小，而所有右元素都大于它。 注意：左侧和右侧元素可以等于所需元素。并且极端元素不能是必需元素。
### 输入描述
输入的第一行包含一个整数T，表示测试用例的数量。然后是T测试用例。每个测试用例由两行组成。每个测试用例的第一行包含一个整数N，表示数组的大小，第二行包含N个以空格分隔的数组元素。
### 输出描述
对于每个测试用例，在新行中打印所需的元素。如果数组中没有这样的元素，则打印-1。
### 输入范例
```
3
4
4 2 5 7
3
11 9 12
6
4 3 2 7 8 9
```
### 输出范例
```
5
-1
7
```
### 题目来源
geeksforgeeks.org
"
差异系列_1578276411758,"## 题目描述
给定一系列从n = 1开始的数字3、10、21、36…。和序列，找到模式并输出上述序列的第n个值。
## 输入描述
输入的第一行包含一个整数T，表示测试用例的数量。 每个测试用例的第一行包含n。1 ≤ T ≤ 100；
1 ≤ n ≤ 100
## 输出描述
对于每个测试用例，输出上述系列的第n个值
## 样例输入
4
1
2
3
4
## 样例输出
3
10
21
36
## 题目来源
geeksforgeeks.org"
广度优先遍历图_1577867780412,"### 题目描述
按照给定的起始顶点广度优先遍历图，每一次通过字母顺序选择顶点查找下一层邻接点，打印遍历顺序。
### 输入描述
```
输入第一行为测试用例个数，后面每一个用例用多行表示，用例第一行是节点个数n和开始顶点，用空格隔开，后面n+1行为图的邻接矩阵，其中第一行为节点名称。值之间使用空格隔开。
```
### 输出描述
```
输出遍历顺序，用空格隔开。
```
### 测试样例
#### 样例1:输入-输出-解释
```
1
4 a
a b c d
a 0 1 1 0
b 1 0 1 0
c 1 1 0 1
d 0 0 1 0
```
```
a b c d
```"
序列元素_1578276704860,"## 题目描述
考虑一系列仅由数字4和7组成的数字，例如4、7、44、47、74，...... 44744等。给定一个数字n，我们需要在其中找到第n个数字该系列。
## 输入描述
输入的第一行包含一个整数T，它表示测试用例的数量。然后是T测试用例。每个测试用例包含一个整数n。1 <= T <= 100；
1 <= N <= 1000
## 输出描述
在新行中打印系列中的第n个数字。
## 样例输入
5
2
3
5
6
11
## 样例输出
7
44
74
77
744
## 题目来源
geeksforgeeks.org"
异或_1580444503050,"### 题目描述
异或是一种神奇的运算,大部分人把它总结成不进位加法.
在生活中…xor运算也很常见。比如，对于一个问题的回答，是为1，否为0.那么：
（A是否是男生 ）xor（ B是否是男生）＝A和B是否能够成为情侣
好了，现在我们来制造和处理一些复杂的情况。比如我们将给出一颗树，它很高兴自己有N个结点。树的每条边上有一个权值。我们要进行M次询问，对于每次询问，我们想知道某两点之间的路径上所有边权的异或值。
### 输入描述
```
输入文件第一行包含一个整数N，表示这颗开心的树拥有的结点数，以下有N-1行，描述这些边，每行有3个数，u,v,w,表示u和v之间有一条权值为w的边。接下来一行有一个整数M，表示询问数。之后的M行，每行两个数u,v，表示询问这两个点之间的路径上的权值异或值。
```
### 输出描述
```
输出M行，每行一个整数，表示异或值
```
### 测试样例
#### 样例1:输入-输出-解释
```
5
1 4 9644
2 5 15004
3 1 14635
5 3 9684
3
2 4
5 4
1 1
```
```
975
14675
0
```
```
无
```
### 题目来源  
`luogu.com.cn`"
循环排序_1580375704830,"### 题目描述
<p align="""">
	<img src=""http://mooctest-code.oss-cn-shanghai.aliyuncs.com/static/media/%E5%BE%AA%E7%8E%AF%E6%8E%92%E5%BA%8F.png"" alt=""Sample""  width=""800"" height=""115"">
</p>
### 输入描述
<p align="""">
	<img src=""http://mooctest-code.oss-cn-shanghai.aliyuncs.com/static/media/%E5%BE%AA%E7%8E%AF%E6%8E%92%E5%BA%8F2.png"" alt=""Sample""  width=""360"" height=""36"">
</p>
### 输出描述
<p align="""">
	<img src=""http://mooctest-code.oss-cn-shanghai.aliyuncs.com/static/media/%E5%BE%AA%E7%8E%AF%E6%8E%92%E5%BA%8F3.png"" alt=""Sample""  width=""530"" height=""80"">
</p>
### 测试样例
#### 样例1: 输入-输出-解释
```
5 5
3 2 3 1 1
```
```
1
5
1 4 2 3 5
```
```
你可以用两次操作1-4-1和2-3-5-2排序数组，但这样会 WA，因为你的任务是最小化q，而最优解的q=1。
一种可行的方法是1-4-2-3-5-1，即样例输出。
```
### 题目来源  
`eJOI`"
总和第N行_1578276140585,"## 题目描述
给定一个序列，如下所示： 
1 2
3 4 5 6
7 8 9 10 11 12
13 14 15 16 17 18 19 20
............................. 
............................ （依此类推） 
给您一个数字N，您需要编写一个程序来查找上述系列的第N行中所有元素的总和
## 输入描述
输入的第一行包含一个整数T，它表示测试用例的数量。每个测试用例的第一行包含一个整数N。1<=T<=100；1<=N<=100
## 输出描述
对于每个测试用例，请打印上述系列的第N行中存在的所有元素的总和。
## 样例输入
2
2
4
## 样例输出
18
132
## 题目来源
geeksforgeeks.org"
成对元素_1580209509978,"### 题目描述
给定一个由N个正整数和另一个数字X组成的数组A。确定A中是否存在两个元素的总和恰好为X。
### 输入描述
输入的第一行包含一个整数T，表示测试用例的数量。每个测试用例的第一行是N和X，N是数组的大小。每个测试用例的第二行包含代表数组元素A [i]的N个整数。
### 输出描述
如果A中存在两个元素的总和恰好为X，则打印“Yes”，否则为“No”（不带引号）。
### 输入范例
```
2
6 16
1 4 45 6 10 8
5 10
1 2 4 3 6
```
### 输出范例
```
Yes
Yes
```
### 题目来源
geeksforgeeks.org
"
打印支架编号_1578141434336,"## 题目描述
给定一个表达式exp，长度为n，由一些括号组成。任务是在解析表达式时打印括号编号。
## 输入描述
第一行包含一个整数T，即测试用例的数量。对于每个测试用例，都有一个包含表达式的字符串exp。1<=T<=100;1<=S<=100
## 输出描述
对于每个测试用例，输出为表达式的括号编号。
## 样例输入
3
(a+(b*c))+(d/e)
((())(()))
((((()
## 样例输出
1 2 2 1 3 3
1 2 3 3 2 4 5 5 4 1
1 2 3 4 5 5
## 题目来源
geeksforgeeks.org"
找出井字棋的获胜者_1580879162570,"### 题目描述
A 和 B 在一个 3 x 3 的网格上玩井字棋。
井字棋游戏的规则如下：
	玩家轮流将棋子放在空方格 ("" "") 上。
	第一个玩家 A 总是用 ""X"" 作为棋子，而第二个玩家 B 总是用 ""O"" 作为棋子。
	""X"" 和 ""O"" 只能放在空方格中，而不能放在已经被占用的方格上。
	只要有 3 个相同的（非空）棋子排成一条直线（行、列、对角线）时，游戏结束。
	如果所有方块都放满棋子（不为空），游戏也会结束。
	游戏结束后，棋子无法再进行任何移动。
给你一个数组 moves，其中每个元素是大小为 2 的另一个数组（元素分别对应网格的行和列），它按照 A 和 B 的行动顺序（先 A 后 B）记录了两人各自的棋子位置。
如果游戏存在获胜者（A 或 B），就返回该游戏的获胜者；如果游戏以平局结束，则返回 ""Draw""；如果仍会有行动（游戏未结束），则返回 ""Pending""。
你可以假设 moves 都 有效（遵循井字棋规则），网格最初是空的，A 将先行动。
### 输入描述
```
一个数组 moves，其中每个元素是大小为 2 的另一个数组（元素分别对应网格的行和列），它按照 A 和 B 的行动顺序（先 A 后 B）记录了两人各自的棋子位置。
1 <= moves.length <= 9
moves[i].length == 2
0 <= moves[i][j] <= 2
moves 里没有重复的元素。
moves 遵循井字棋的规则。
```
### 输出描述
```
如果游戏存在获胜者（A 或 B），就返回该游戏的获胜者；如果游戏以平局结束，则返回 ""Draw""；如果仍会有行动（游戏未结束），则返回 ""Pending""。
```
### 测试样例
#### 样例1: 输入-输出-解释
```
[[0,0],[2,0],[1,1],[2,1],[2,2]]
```
```
A
```
```
""A"" 获胜，他总是先走。
""X  ""    ""X  ""    ""X  ""    ""X  ""    ""X  ""
""   "" -> ""   "" -> "" X "" -> "" X "" -> "" X ""
""   ""    ""O  ""    ""O  ""    ""OO ""    ""OOX""
```
### 题目来源  
`LeetCode`"
找相同字符_1578246661060,"### 题目描述
给定两个字符串，求出在两个字符串中各取出一个子串使得这两个子串相同的方案数。两个方案不同当且仅当这两个子串中有一个位置不同。
### 输入描述
```
两行，两个字符串s1,s2，长度分别为n1,n2。字符串中只有小写字母。
数据范围：1≤n1,n2≤200000
```
### 输出描述
```
输出一个整数表示答案
```
### 测试样例
#### 样例1:输入-输出-解释
```
aabb
bbaa
```
```
10
```"
拯救钢铁侠_1580287906143,"### 题目描述
贾维斯在计算字母数字字符回文率方面很弱。 当钢铁侠忙于与灭霸战斗时，他需要启动音速冲动，但是贾维斯不会计算回文。给定一个包含字母数字字符的字符串S，找出字符串是否是回文，拯救钢铁侠。
### 输入描述
输入的第一行包含T，即测试用例的数量。随后是T个测试用例。测试用例的每一行都包含字符串“S”。
### 输出描述
如果字符串是回文，则输出的每一行都包含“ YES”，如果字符串不是回文，则输出“ NO”。
### 输入范例
```
2
I am :IronnorI Ma, i
Ab?/Ba
```
### 输出范例
```
YES
YES
```
### 题目来源
geeksforgeeks.org
"
指定累加和的最长路径长度_1580113272457,"### 题目描述
给定一颗二叉树和一个整数 sum，求累加和为 sum 的最长路径长度。路径是指从某个节点往下，每次最多选择一个孩子节点或者不选所形成的节点链。
### 输入描述
```
第一行输入两个整数 n 和 root，n 表示二叉树的总节点个数，root 表示二叉树的根节点。
以下 n 行每行四个整数 fa，lch，rch，val，表示 fa 的左儿子为 lch，右儿子为 rch。val 表示 fa 节点的值(如果 lch 为 0 则表示 fa 没有左儿子，rch同理)
```
### 输出描述
```
输出一个整数表示最长链的长度。
```
### 测试样例
#### 样例1:输入-输出-解释
```
9 1
1 2 3 -3
2 4 5 3
4 0 0 1
5 8 9 0
8 0 0 1
9 0 0 6
3 6 7 -9
6 0 0 2
7 0 0 1
6
```
```
4
```
```
无
```
#### 样例2: 输入-输出-解释
```
9 1
1 2 3 -3
2 4 5 3
4 0 0 1
5 8 9 0
8 0 0 1
9 0 0 6
3 6 7 -9
6 0 0 2
7 0 0 1
-9
```
```
1
```
```
无
```
### 题目来源  
`nowcoder.com`"
按奇偶排序数组_1580536106585,"### 题目描述
给定一个非负整数数组 A， A 中一半整数是奇数，一半整数是偶数。
对数组进行排序，以便当 A[i] 为奇数时，i 也是奇数；当 A[i] 为偶数时， i 也是偶数。
你可以返回任何满足上述条件的数组作为答案。
### 输入描述
```
一个非负整数数组。
2 <= A.length <= 20000
A.length % 2 == 0
0 <= A[i] <= 1000
```
### 输出描述
```
排序后的数组
```
### 测试样例
#### 样例1: 输入-输出-解释
```
[4,2,5,7]
```
```
[4,5,2,7]
```
```
[4,7,2,5]，[2,5,4,7]，[2,7,4,5] 也会被接受。
```"
按层和ZigZag打印二叉树_1580185968180,"### 题目描述
给定一颗二叉树，分别实现按层和 ZigZag 打印二叉树。
ZigZag遍历: 意思是第一层从左到右遍历，第二层从右到左遍历，依次类推。
### 输入描述
```
第一行输入两个整数 n 和 root，n 表示二叉树的总节点个数，root 表示二叉树的根节点。
以下 n 行每行三个整数 fa，lch，rch，表示 fa 的左儿子为 lch，右儿子为 rch。(如果 lch 为 0 则表示 fa 没有左儿子，rch同理)
```
### 输出描述
```
先输出按层打印，再输出按ZigZag打印。
```
### 测试样例
#### 样例1:输入-输出-解释
```
8 1
1 2 3
2 4 0
4 0 0
3 5 6
5 7 8
6 0 0
7 0 0
8 0 0
```
```
Level 1 : 1
Level 2 : 2 3
Level 3 : 4 5 6
Level 4 : 7 8
Level 1 from left to right: 1
Level 2 from right to left: 3 2
Level 3 from left to right: 4 5 6
Level 4 from right to left: 8 7
```
```
无
```
### 题目来源  
`nowcoder.com`"
排序二叉树_1580361571717,"### 题目描述
一个边长为n的正三角形可以被划分成若干个小的边长为1的正三角形，称为单位三角形。如下图，边长为3的正三角形被分成三层共九个小的正三角形，我们把它们从顶到底，从左到右以1到9编号(见右图)。同理，边长为n的正三角形可以划分成n<sup>2</sup>个单位三角形。
<p align=""center"">
	<img src=""http://mooctest-code.oss-cn-shanghai.aliyuncs.com/static/media/%E6%8E%92%E5%BA%8F%E4%BA%8C%E5%8F%89%E6%A0%91.png"" alt=""Sample""  width=""125"" height=""100"">
</p>
四个这样的边长为n的正三角形可以组成一个三棱锥。我们将正三棱锥的三个侧面依顺时针次序（从顶向底视角）编号为A,B,C，底面编号为D。侧面的A,B,C号三角形以三棱锥的顶点为顶，底面的D号三角形以它与A,B三角形的交点为顶。下图为三棱锥展开后的平面图，每个面上标有圆点的是该面的顶，该图中侧面 A,B,C分别向纸内方向折叠即可还原成三棱锥。我们把这A、B、C、D四个面各自划分成n<sup>2</sup>个单位三角形。
<p align=""center"">
	<img src=""http://mooctest-code.oss-cn-shanghai.aliyuncs.com/static/media/%E6%8E%92%E5%BA%8F%E4%BA%8C%E5%8F%89%E6%A0%912.png"" alt=""Sample""  width=""140"" height=""125"">
</p>
对于任意两个单位三角形，如有一条边相邻，则称它们为相邻的单位三角形，显然，每个单位三角形有三个相邻的单位三角形。现在，把1~4n<sup>2</sup>分别随机填入四个面总共4n<sup>2</sup>个单位三角形中。
现在要求你编程求由单位三角形组成的最大排序二叉树。所谓最大排序二叉树，是指在所有由单位三角形组成的排序二叉树中节点最多的一棵树。对于任一单位三角形，可选它三个相邻的单位三角形中任意一个作为父节点，其余两个分别作为左孩子和右孩子。当然，做根节点的单位三角形不需要父节点，而左孩子和右孩子对于二叉树中的任意节点来说并不是都必须的。
### 输入描述
第一行是一个整数n，随后4n<sup>2</sup>行，依次为三棱锥四个面上所填的数字。
数据范围：1≤n≤18
### 输出描述
```
输出仅包含一个整数，表示最大的排序二叉树所含的节点数目。
```
### 测试样例
#### 样例1: 输入-输出-解释
```
3
19
33
32
31
29
3
5
4
30
22
25
20
21
12
24
23
34
35
14
13
15
26
18
17
8
16
27
11
10
9
1
28
7
2
6
36
```
```
17
```
样例解释：
<p align=""center"">
	<img src=""http://mooctest-code.oss-cn-shanghai.aliyuncs.com/static/media/%E6%8E%92%E5%BA%8F%E4%BA%8C%E5%8F%89%E6%A0%913.png"" alt=""Sample""  width=""800"" height=""600"">
</p>
### 题目来源  
`CTSC`"
排序交换_1580303259115,"### 题目描述
<p align=""center"">
	<img src=""http://mooctest-code.oss-cn-shanghai.aliyuncs.com/static/media/%E6%8E%92%E5%BA%8F%E4%BA%A4%E6%8D%A2.png"" alt=""Sample""  width=""800"" height=""125"">
</p>
### 输入描述
第一行一个整数n。
第二行2<sup>n</sup>个整数，表示A[1...2<sup>n</sup>]。
数据范围：1≤N≤12
### 输出描述
```
一个整数表示答案。
```
### 测试样例
#### 样例1:输入-输出-解释
```
3
7 8 5 6 1 2 4 3
```
```
6
```
### 题目来源  
`SDOI`"
排序机械臂_1580358588714,"### 题目描述
SORT 公司是一个专门为人们提供排序服务的公司，该公司的宗旨是「顺序是最美丽的」。
为了把工厂中高低不等的物品按从低到高排好序，工程师发明了一种排序机械臂。
它遵循一个简单的排序规则，第一次操作找到高度最低的物品的位置P<sub>1</sub>，并把左起第一个物品至P<sub>1</sub>间的物品（即区间[1,P<sub>1</sub>]间的物品）反序；第二次找到第二低的物品的位置P<sub>2</sub>，并把左起第二个至P<sub>2</sub>间的物品（即区间[2,P<sub>2</sub>]间的物品）反序……最终所有的物品都会被排好序。
<p align="""">
	<img src=""http://mooctest-code.oss-cn-shanghai.aliyuncs.com/static/media/%E6%8E%92%E5%BA%8F%E6%9C%BA%E6%A2%B0%E8%87%82.png"" alt=""Sample""  width=""500"" height=""120"">
</p>
上图给出有六个物品的示例，第一次操作前，高度最低的物品在位置4，于是把第一至第四的物品反序；第二次操作前，第二低的物品在位罝六，于是把第二至六的物品反序……
你的任务便是编写一个程序，确定一个操作序列，即每次操作前第i低的物品所在位置P<sub>i</sub>，以便机械臂工作。需要注意的是，如果有高度相同的物品，必须保证排序后它们的相对位置关系与初始时相同。
### 输入描述
```
输入共两行，第一行为一个整数N，N表示物品的个数。
第二行为N个用空格隔开的正整数，表示N个物品最初排列的编号
```
### 输出描述
输出共一行，N个用空格隔开的正整数P<sub>1</sub>,P<sub>2</sub>,...,P<sub>n</sub>，P<sub>i</sub>表示第i次操作前第i小的物品所在的位置。
注意：如果第i次操作前，第i小的物品己经在正确的位置P<sub>i</sub>上，我们将区间[P<sub>i</sub>,P<sub>i</sub>]反转 (单个物品)。
### 测试样例
#### 样例1:输入-输出-解释
```
6
3 4 5 1 6 2
```
```
4 6 4 5 6 6
```
### 题目来源  
`CQOI`"
排序链表_1580446556918,"### 题目描述
在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。
### 输入描述
```
一个未排序的数组
```
### 输出描述
```
排好序的数组
```
### 测试样例
#### 样例1: 输入-输出-解释
```
[4,2,1,3]
```
```
[1,2,3,4]
```"
搜索插入位置_1580449614614,"### 题目描述
<p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>
<p>你可以假设数组中无重复元素。</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> [1,3,5,6], 5
<strong>输出:</strong> 2
</pre>
<p><strong>示例&nbsp;2:</strong></p>
<pre><strong>输入:</strong> [1,3,5,6], 2
<strong>输出:</strong> 1
</pre>
<p><strong>示例 3:</strong></p>
<pre><strong>输入:</strong> [1,3,5,6], 7
<strong>输出:</strong> 4
</pre>
<p><strong>示例 4:</strong></p>
<pre><strong>输入:</strong> [1,3,5,6], 0
<strong>输出:</strong> 0
</pre>
### 样例输入<br>
```
1,3,5,6
5
```
### 样例输出<br>
```
2
```
### 题目来源  
`LeetCode`"
搜索旋转排序数组 II_1580450621478,"### 题目描述
<p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p>
<p>( 例如，数组&nbsp;<code>[0,0,1,2,2,5,6]</code>&nbsp;可能变为&nbsp;<code>[2,5,6,0,0,1,2]</code>&nbsp;)。</p>
<p>编写一个函数来判断给定的目标值是否存在于数组中。若存在返回&nbsp;<code>true</code>，否则返回&nbsp;<code>false</code>。</p>
<p><strong>示例&nbsp;1:</strong></p>
<pre><strong>输入:</strong> nums = [2<code>,5,6,0,0,1,2]</code>, target = 0
<strong>输出:</strong> True
</pre>
<p><strong>示例&nbsp;2:</strong></p>
<pre><strong>输入:</strong> nums = [2<code>,5,6,0,0,1,2]</code>, target = 3
<strong>输出:</strong> False</pre>
<p><strong>进阶:</strong></p>
<ul>
	<li>这是 <a href=""https://leetcode-cn.com/problems/search-in-rotated-sorted-array/description/"">搜索旋转排序数组</a>&nbsp;的延伸题目，本题中的&nbsp;<code>nums</code>&nbsp; 可能包含重复元素。</li>
	<li>这会影响到程序的时间复杂度吗？会有怎样的影响，为什么？</li>
</ul>
### 样例输入<br>
```
2,5,6,0,0,1,2
0
```
### 样例输出<br>
```
True
```
### 题目来源  
`LeetCode`"
搜索旋转排序数组_1580449309410,"### 题目描述
<p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p>
<p>( 例如，数组&nbsp;<code>[0,1,2,4,5,6,7]</code>&nbsp;可能变为&nbsp;<code>[4,5,6,7,0,1,2]</code>&nbsp;)。</p>
<p>搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回&nbsp;<code>-1</code>&nbsp;。</p>
<p>你可以假设数组中不存在重复的元素。</p>
<p>你的算法时间复杂度必须是&nbsp;<em>O</em>(log&nbsp;<em>n</em>) 级别。</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> nums = [<code>4,5,6,7,0,1,2]</code>, target = 0
<strong>输出:</strong> 4
</pre>
<p><strong>示例&nbsp;2:</strong></p>
<pre><strong>输入:</strong> nums = [<code>4,5,6,7,0,1,2]</code>, target = 3
<strong>输出:</strong> -1</pre>
### 样例输入<br>
```
4,5,6,7,0,1,2
0
```
### 样例输出<br>
```
4
```
### 题目来源  
`LeetCode`"
收集树木_1580799100843,"### 题目描述
给定一个数N，并无限供应各种深度的完整二叉树。您的任务是选择最小数量的二叉树，以使您选择的每棵树的叶节点总数之和为N. 
注意：对于仅具有根节点的二叉树：深度= 1，叶节点= 1
### 输入描述
输入的第一行包含一个整数T，表示测试用例的总数。然后是T测试用例。如问题陈述中所述，测试用例的每一行都包含一个整数N.
### 输出描述
对于每个测试用例，请打印一行，其中包含您需要采摘的最少树木数量。
### 输入范例
```
2
1
5
```
### 输出范例
```
1
2
```
### 题目来源
geeksforgeeks.org
"
数字 1 的个数_1578050473039,"## 题目描述
<p>给定一个整数 n，计算所有小于等于 n 的非负整数中数字 1 出现的个数。</p>
<p><strong>示例:</strong></p>
<pre><strong>输入:</strong> 13
<strong>输出:</strong> 6 
<strong>解释: </strong>数字 1 出现在以下数字中: 1, 10, 11, 12, 13 。</pre>"
数组中的第K个最大元素_1580572732333,"### 题目描述
在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。
### 输入描述
```
一个未排序的数组和一个整数k。你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。
```
### 输出描述
```
第 k 个最大的元素。
```
### 测试样例
#### 样例1: 输入-输出-解释
```
[3,2,1,5,6,4]
2
```
```
5
```
### 题目来源  
`LeetCode`"
数组中缺少数字_1580021731174,"### 题目描述
给定大小为N-1的数组C，并且存在从1到N的数字且缺少一个元素，将找到缺失的数字。
### 输入描述
输入的第一行包含一个整数T，表示测试用例的数量。对于每个测试用例，第一行包含N（数组大小）。下一行包含N-1个数组元素。
### 输出描述
打印数组中缺少的数字。
### 输入范例
```
2
5
1 2 3 5
10
1 2 3 4 5 6 7 8 10
```
### 输出范例
```
4
9
```
### 题目来源
geeksforgeeks.org
"
整数反转_1577412407681,"## 题目描述
给出一个32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。
## 输入描述
一个整数
## 输出描述
一个整数
## 样例输入
123
## 样例输出
321"
整数拆分_1578055217390,"## 题目描述
<p>给定一个正整数&nbsp;<em>n</em>，将其拆分为<strong>至少</strong>两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入: </strong>2
<strong>输出: </strong>1
<strong>解释: </strong>2 = 1 + 1, 1 × 1 = 1。</pre>
<p><strong>示例&nbsp;2:</strong></p>
<pre><strong>输入: </strong>10
<strong>输出: </strong>36
<strong>解释: </strong>10 = 3 + 3 + 4, 3 ×&nbsp;3 ×&nbsp;4 = 36。</pre>
<p><strong>说明: </strong>你可以假设&nbsp;<em>n&nbsp;</em>不小于 2 且不大于 58。</p>"
整数转换英文表示_1578052667053,"## 题目描述
<p>将非负整数转换为其对应的英文表示。可以保证给定输入小于&nbsp;2<sup>31</sup> - 1 。</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> 123
<strong>输出:</strong> ""One Hundred Twenty Three""
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong> 12345
<strong>输出:</strong> ""Twelve Thousand Three Hundred Forty Five""</pre>
<p><strong>示例 3:</strong></p>
<pre><strong>输入:</strong> 1234567
<strong>输出:</strong> ""One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven""</pre>
<p><strong>示例 4:</strong></p>
<pre><strong>输入:</strong> 1234567891
<strong>输出:</strong> ""One Billion Two Hundred Thirty Four Million Five Hundred Sixty Seven Thousand Eight Hundred Ninety One""</pre>"
整数转罗马数字_1577685311995,"## 题目描述
<p>罗马数字包含以下七种字符：&nbsp;<code>I</code>，&nbsp;<code>V</code>，&nbsp;<code>X</code>，&nbsp;<code>L</code>，<code>C</code>，<code>D</code>&nbsp;和&nbsp;<code>M</code>。</p>
<pre><strong>字符</strong>          <strong>数值</strong>
I             1
V             5
X             10
L             50
C             100
D             500
M             1000</pre>
<p>例如， 罗马数字 2 写做&nbsp;<code>II</code>&nbsp;，即为两个并列的 1。12 写做&nbsp;<code>XII</code>&nbsp;，即为&nbsp;<code>X</code>&nbsp;+&nbsp;<code>II</code>&nbsp;。 27 写做&nbsp;&nbsp;<code>XXVII</code>, 即为&nbsp;<code>XX</code>&nbsp;+&nbsp;<code>V</code>&nbsp;+&nbsp;<code>II</code>&nbsp;。</p>
<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做&nbsp;<code>IIII</code>，而是&nbsp;<code>IV</code>。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为&nbsp;<code>IX</code>。这个特殊的规则只适用于以下六种情况：</p>
<ul>
	<li><code>I</code>&nbsp;可以放在&nbsp;<code>V</code>&nbsp;(5) 和&nbsp;<code>X</code>&nbsp;(10) 的左边，来表示 4 和 9。</li>
	<li><code>X</code>&nbsp;可以放在&nbsp;<code>L</code>&nbsp;(50) 和&nbsp;<code>C</code>&nbsp;(100) 的左边，来表示 40 和&nbsp;90。&nbsp;</li>
	<li><code>C</code>&nbsp;可以放在&nbsp;<code>D</code>&nbsp;(500) 和&nbsp;<code>M</code>&nbsp;(1000) 的左边，来表示&nbsp;400 和&nbsp;900。</li>
</ul>
<p>给定一个整数，将其转为罗马数字。输入确保在 1&nbsp;到 3999 的范围内。</p>
<p><strong>示例&nbsp;1:</strong></p>
<pre><strong>输入:</strong>&nbsp;3
<strong>输出:</strong> ""III""</pre>
<p><strong>示例&nbsp;2:</strong></p>
<pre><strong>输入:</strong>&nbsp;4
<strong>输出:</strong> ""IV""</pre>
<p><strong>示例&nbsp;3:</strong></p>
<pre><strong>输入:</strong>&nbsp;9
<strong>输出:</strong> ""IX""</pre>
<p><strong>示例&nbsp;4:</strong></p>
<pre><strong>输入:</strong>&nbsp;58
<strong>输出:</strong> ""LVIII""
<strong>解释:</strong> L = 50, V = 5, III = 3.
</pre>
<p><strong>示例&nbsp;5:</strong></p>
<pre><strong>输入:</strong>&nbsp;1994
<strong>输出:</strong> ""MCMXCIV""
<strong>解释:</strong> M = 1000, CM = 900, XC = 90, IV = 4.</pre>"
文艺平衡树_1578645862113,"### 题目描述
您需要写一种数据结构（可参考题目标题），来维护一个序列，其中需要提供以下操作：
翻转一个区间，例如原有序序列是 5 4 3 2 1，翻转区间是[2,4]的话，结果是 5 2 3 4 1。
### 输入描述
```
第一行为年n,m，n表示初始序列有n个数，这个序列依次是{1,2,...,n-1,n}，m表示翻转操作次数。
接下来m行每行两个数[l,r]，数据保证1≤l≤r≤n。
```
### 输出描述
```
输出一行n个数字，表示原始序列经过m次变换后的结果。
```
### 测试样例
#### 样例1:输入-输出-解释
```
5 3
1 3
1 3
1 4
```
```
4 3 2 1 5
```"
斯蒂克勒小偷_1580288377900,"### 题目描述
斯蒂勒小偷想从一个只有一行房屋的社区中抢钱。他是一个奇怪的人，在洗劫房屋时遵循一定的规则。根据规则，他将永远不会抢劫连续两所房子。同时，他想最大化他所掠获的数量。小偷知道哪所房子有多少钱，但无法提出最佳的抢劫策略。如果他严格遵守规则，他会寻求您的帮助，以寻求最大的收益。每个房屋中都有a[i]金额。
### 输入描述
输入的第一行包含一个整数T，表示测试用例的数量。随后是T个测试用例。每个测试用例均包含一个整数n，表示房屋数量。下一行包含用空格分隔的数字，表示每所房子的钱数
### 输出描述
对于每个测试用例，在换行符中，打印一个整数，该整数表示他可以带回家的最大金额。
### 输入范例
```
2
6
5 5 10 100 10 5
3
1 2 3
```
### 输出范例
```
110
4
```
### 题目来源
geeksforgeeks.org
"
旋转阵列_1580212176814,"### 题目描述
给定一个N大小的数组。d小于等于N，以d个元素为一组将数组进行旋转。
```
Example :
Input :  arr[] = [1, 2, 3, 4, 5, 6, 7]
         d = 2
Output : arr[] = [3, 4, 5, 6, 7, 1, 2] 
每两个元素为一组，即1和2为一组，3和4为一组，以此类推。第一组转到最后，第二组转为第一组。
```
### 输入描述
输入的第一行包含一个整数T，表示测试用例的数量。然后是T测试用例。每个测试用例包含三行。每个测试用例的第一行由整数N组成，其中N是数组的大小。 每个测试用例的第二行包含N个以空格分隔的整数，表示数组元素。每个测试用例的第三行包含“ d”。
### 输出描述
对应于每个测试用例，在新行中打印修改后的数组。
### 输入范例
```
1
5
1 2 3 4 5
2
```
### 输出范例
```
3 4 5 1 2
```
### 题目来源
geeksforgeeks.org
"
早会_1580741639616,"### 题目描述
Eveyone记得在学校集会上要排队。有一天，很少有学生在早上开会的时候迟到，所以他们就去排队了。但是他们的校长很严格，使他们升序站立。 给定一个由N个元素组成的数组，代表最短的人和1个最高的人。他考虑通过技巧来安排队列，技巧很简单：选择一个学生，最后或首先派遣他/她，并根据身高进行安排。但是他需要您的帮助。 如果最初或最后发送一个学生，则成本增加一倍。
### 输入描述
第一行包含T个测试用例。测试用例的第一行包含N。每个测试用例的第二行包含N个元素。
### 输出描述
单行输出，输出最低代价。
### 输入范例
```
2
3
2 1 3
4
4 3 1 2
```
### 输出范例
```
1
2
```
### 题目来源
geeksforgeeks.org
"
普通平衡树_1578640784521,"### 题目描述
您需要写一种数据结构（可参考题目标题），来维护一些数，其中需要提供以下操作：
插入x数；
删除x数（若有多个相同的数，因只删除一个）；
查询x数的排名（若有多个相同的数，因输出最小的排名）；
查询排名为x的数；
求x的前趋（前趋定义为小于 ，且最大的数）；
求x的后继（后继定义为大于 ，且最小的数）。
### 输入描述
```
第一行为n，表示操作的个数，下面n行每行有两个数opt和x，opt表示操作的序号（1<=opt<=6）。
```
### 输出描述
```
对于操作 3、4、5、6 每行输出一个数，表示对应答案。
```
### 测试样例
#### 样例1:输入-输出-解释
```
10
1 106465
4 1
1 317721
1 460929
1 644985
1 84185
1 89851
6 81968
1 492737
5 493598
```
```
106465
84185
492737
```"
最多能完成排序的块_1580566432492,"### 题目描述
数组arr是[0, 1, ..., arr.length - 1]的一种排列，我们将这个数组分割成几个“块”，并将这些块分别进行排序。之后再连接起来，使得连接的结果和按升序排序后的原数组相同。
我们最多能将数组分成多少块？
### 输入描述
```
数组arr。arr 的长度在 [1, 10] 之间。arr[i]是 [0, 1, ..., arr.length - 1]的一种排列。
```
### 输出描述
```
数组分割成的块数
```
### 测试样例
#### 样例1: 输入-输出-解释
```
[4,3,2,1,0]
```
```
1
```
```
将数组分成2块或者更多块，都无法得到所需的结果。
例如，分成 [4, 3], [2, 1, 0] 的结果是 [3, 4, 0, 1, 2]，这不是有序的数组。
```
### 题目来源  
`LeetCode`"
最大整除子集_1578119645442,"## 题目描述
<p>给出一个由<strong>无重复的</strong>正整数组成的集合，找出其中最大的整除子集，子集中任意一对 (S<sub>i，</sub>S<sub>j</sub>) 都要满足：S<sub>i</sub> % S<sub>j</sub> = 0 或 S<sub>j</sub> % S<sub>i</sub> = 0。</p>
<p>如果有多个目标子集，返回其中任何一个均可。</p>
<p>&nbsp;</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> 1,2,3
<strong>输出:</strong> [1,2] (当然, [1,3] 也正确)
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong> 1,2,4,8
<strong>输出:</strong> [1,2,4,8]
</pre>"
最大间距_1580447368478,"### 题目描述
给定一个无序的数组，找出数组在排序之后，相邻元素之间最大的差值。
如果数组元素个数小于 2，则返回 0。
### 输入描述
```
一个无序的数组
```
### 输出描述
```
如果元素大于等于2，则输出排序之后，相邻元素之间最大的差值；否则输出0
```
### 测试样例
#### 样例1: 输入-输出-解释
```
[3,6,9,1]
```
```
3
```
```
排序后的数组是 [1,3,6,9], 其中相邻元素 (3,6) 和 (6,9) 之间都存在最大差值 3。
```"
最长K个唯一字符子字符串_1580613716698,"### 题目描述
给定一个字符串，您需要打印具有恰好k个唯一字符的最长子字符串的大小。如果没有可能的子字符串，则打印-1。 
例 
对于字符串abacbebebe和k = 3，子字符串将为cbebebe，长度为7。
### 输入描述
输入的第一行包含一个整数T，表示测试用例的数量，然后是T个测试用例。每个测试用例包含两行。每个测试用例的第一行包含一个字符串s，下一行包含一个整数k。
### 输出描述
对于换行中的每个测试用例，请打印所需的输出。
### 输入范例
```
2
aabacbebebe
3
aaaa
1
```
### 输出范例
```
7
4
```
### 题目来源
geeksforgeeks.org
"
最长上升子序列_1580538307961,"### 题目描述
<p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p>
<p><strong>示例:</strong></p>
<pre><strong>输入:</strong> <code>[10,9,2,5,3,7,101,18]
</code><strong>输出: </strong>4 
<strong>解释: </strong>最长的上升子序列是&nbsp;<code>[2,3,7,101]，</code>它的长度是 <code>4</code>。</pre>
<p><strong>说明:</strong></p>
<ul>
	<li>可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。</li>
	<li>你算法的时间复杂度应该为&nbsp;O(<em>n<sup>2</sup></em>) 。</li>
</ul>
<p><strong>进阶:</strong> 你能将算法的时间复杂度降低到&nbsp;O(<em>n</em> log <em>n</em>) 吗?</p>
### 样例输入<br>
```
10,9,2,5,3,7,101,18
```
### 样例输出<br>
```
4
```
### 题目来源  
`LeetCode`"
最长有效括号_1580472427940,"### 题目描述
给定一个字符串S，该字符串由左括号“（”和“）”组成。查找最长的有效括号子字符串的长度。
### 输入描述
第一行包含测试用例T的数量。每个测试用例都有一个字符串N，长度为'（'和'）'。
### 输出描述
输出最长的有效括号子字符串的长度
### 输入范例
```
2
((()
)()())
```
### 输出范例
```
2
4
```
### 题目来源
geeksforgeeks.org
"
最长连续序列_1580575865453,"### 题目描述
给定一个未排序的整数数组，找出最长连续序列的长度。
要求算法的时间复杂度为 O(n)。
### 输入描述
```
一个未排序的整数数组
```
### 输出描述
```
最长连续序列的长度
```
### 测试样例
#### 样例1: 输入-输出-解释
```
[100, 4, 200, 1, 3, 2]
```
```
4
```
```
最长连续序列是 [1, 2, 3, 4]。它的长度为 4。
```
### 题目来源  
`LeetCode`"
最长连续递增序列_1580964533662,"### 题目描述
给定一个未经排序的整数数组，找到最长且连续的的递增序列。
### 输入描述
```
一个未经排序的整数数组
数组长度不会超过1000。
```
### 输出描述
```
找到最长且连续的的递增序列
```
### 测试样例
#### 样例1: 输入-输出-解释
```
[1,3,5,4,7]
```
```
3
```
```
最长连续递增序列是 [1,3,5], 长度为3。
尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为5和7在原数组里被4隔开。 
```
### 题目来源  
`LeetCode`"
有效数字_1578046417861,"## 题目描述
<p>验证给定的字符串是否可以解释为十进制数字。</p>
<p>例如:</p>
<p><code>""0""</code>&nbsp;=&gt;&nbsp;<code>true</code><br>
<code>"" 0.1 ""</code>&nbsp;=&gt;&nbsp;<code>true</code><br>
<code>""abc""</code>&nbsp;=&gt;&nbsp;<code>false</code><br>
<code>""1 a""</code>&nbsp;=&gt;&nbsp;<code>false</code><br>
<code>""2e10""</code>&nbsp;=&gt;&nbsp;<code>true</code><br>
<code>"" -90e3&nbsp; &nbsp;""</code>&nbsp;=&gt;&nbsp;<code>true</code><br>
<code>"" 1e""</code>&nbsp;=&gt;&nbsp;<code>false</code><br>
<code>""e3""</code>&nbsp;=&gt;&nbsp;<code>false</code><br>
<code>"" 6e-1""</code>&nbsp;=&gt;&nbsp;<code>true</code><br>
<code>"" 99e2.5&nbsp;""</code>&nbsp;=&gt;&nbsp;<code>false</code><br>
<code>""53.5e93""</code>&nbsp;=&gt;&nbsp;<code>true</code><br>
<code>"" --6 ""</code>&nbsp;=&gt;&nbsp;<code>false</code><br>
<code>""-+3""</code>&nbsp;=&gt;&nbsp;<code>false</code><br>
<code>""95a54e53""</code>&nbsp;=&gt;&nbsp;<code>false</code></p>
<p><strong>说明:</strong>&nbsp;我们有意将问题陈述地比较模糊。在实现代码之前，你应当事先思考所有可能的情况。这里给出一份可能存在于有效十进制数字中的字符列表：</p>"
有效的字母异位词_1580449365191,"### 题目描述
给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。
### 输入描述
```
两个字符串，你可以假设字符串只包含小写字母。
```
### 输出描述
```
true或者false
```
### 测试样例
#### 样例1: 输入-输出-解释
```
s = ""anagram"", t = ""nagaram""
```
```
true
```"
染色_1578054196824,"### 题目描述
pupil 喜欢给图的顶点染颜色。有一天，master 想刁难他，于是给了他一个无重边和自环的无向图， 并且对每个点分别给了一个大小为2的颜色集合，pupil 只能从这个集合中选一种颜色给这个点染色。master 希望 pupil 的染色方案使得没有两个有边相连的点被染了相同的颜色。
现在 pupil 想知道，是否无论 master 的颜色集合是什么，他均有办法按照要求染色。
### 输入描述
```
输入包含多组数据。
第一行一个正整数T，表示数据组数。
之后每组数据第一行两个空格隔开的整数n，m，表示这个无向图的点数和边数。
之后m行，每行两个空格隔开的正整数i，j，表示图中的一条连接点i和点j的边。
图的节点从1开始标号。
数据范围：
对于10%的数据，1≤n≤3;
对于20%的数据，1≤n≤6;
对于50%的数据，1≤n≤1000, 0≤m≤2000;
对于100%的数据，1≤n≤10000，0≤m≤20000, 1≤T≤10。
```
### 输出描述
```
对于每组数据，如果 pupil 无论如何均能染色，输出一行一个字符串 YES，否则输出一行一个字符串 NO。
```
### 测试样例
#### 样例1:输入-输出-解释
```
3
6 9
1 2
1 4
1 6
3 2
3 4
3 6
5 2
5 4
5 6
2 1
1 2
3 3
1 2
1 3
2 3
```
```
NO
YES
NO
```
```
对于第一组数据，如果第一个点和第二个点的集合为{A,B}，第三个点和第四个点的集合为{A,C}，第五个点和第六个点的集合为{B,C}，则奇数点至少使用了两种颜色，偶数点至少使用了两种颜色，因此至少有一个奇数点和一个偶数点颜色相同。但每两个奇数点和每两个偶数点之间均有边， 因此无法满足“没有两个有边相连的点被染了相同的颜色”。
对于第二组数据，无论两个集合是什么，第一个点随便染它的集合中的其中一种颜色，第二个点染它的集合中某个与第一个点不同的颜色即可。
对于第三组数据，如果三个点的集合均是{A,B}，那么无法满足“没有两个有边相连的点被染了相同的颜色”。
```"
查找最近的号码_1580436786414,"### 题目描述
给定一个排序的整数数组。任务是在数组中找到最接近给定数字的值。数组可能包含重复值。 注意：如果两个值的差相同，则打印大于给定数字的值。
### 输入描述
输入的第一行包含一个整数T，表示测试用例的数量。然后是T测试用例。每个测试用例由两行组成。每个测试用例的第一行包含两个整数N和K，第二行包含N个以空格分隔的数组元素。
### 输出描述
对于每个测试用例，在新行中打印最接近的数字。
### 输入范例
```
2
4 4
1 3 6 7
7 4
1 2 3 5 6 8 9
```
### 输出范例
```
3
5
```
### 题目来源
geeksforgeeks.org
"
查找给定总和的所有对_1580281101863,"### 题目描述
给定两个大小不同的元素的未排序数组A和B，A的大小为N，B的大小为M，任务是从两个数组中求和等于X的所有对。
### 输入描述
输入的第一行包含一个整数T，表示测试用例的数量。然后是T测试用例。每个测试用例包含3行。第一行包含3个以空格分隔的整数N，M，X。然后在接下来的两行中分别为数组A和B的以空格分隔的值。
### 输出描述
对于新行中的每个测试用例，请打印所有对u，v对的排序后的空格分隔值，其中u属于数组A，v属于数组B。如果不存在这样的对，则打印-1。
### 输入范例
```
2
5 5 9
1 2 4 5 7
5 6 3 4 8
2 2 3
0 2
1 3
```
### 输出范例
```
1 8
4 5
5 4
0 3
2 1
```
### 题目来源
geeksforgeeks.org
"
查找缺失和重复_1580212520904,"### 题目描述
给定大小为N的正整数的未排序数组。集合{1、2，…N}中的一个数字'A'丢失，数组中两次出现一个数字'B'。找到这两个数字。 注意：如果找到多个答案，则打印找到的最小数字，如没有，打印0
预期的解决方案是O（n）时间和O（n）空间。
### 输入描述
输入的第一行包含一个整数T，表示测试用例的数量。 T测试用例的描述如下。每个测试用例的第一行包含一个表示数组大小的整数N。第二行包含N个以空格分隔的整数A1，A2，...，AN，它们表示数组的元素。
### 输出描述
打印B，在单行中重复的数字后跟A.
### 输入范例
```
2
2
2 2
3 
1 2 3
```
### 输出范例
```
2 1
0 0
```
### 题目来源
geeksforgeeks.org
"
树的分解_1580293890501,"### 题目描述
给出N个点的树和K，问能否把树划分成N/K个连通块，且每个连通块的点数都是K。
### 输入描述
```
第1行，1个整数T，表示数据组数。接下来T组数据，对于每组数据：
第1行，2个整数N,K。
接下来N−1行，每行2个整数A_i,B_i，表示边A_i,B_i。点用1,2,...,N编号。
```
### 输出描述
```
对于每组数据，输出YES或NO。
```
### 测试样例
#### 样例1:输入-输出-解释
```
2
4 2
1 2
2 3
3 4
4 2
1 2
1 3
1 4
```
```
YES
NO
```
```
无
```
### 题目来源  
`luogu.com.cn`"
树的高度_1580196496265,"### 题目描述
现在有一棵合法的二叉树，树的节点都是用数字表示，现在给定这棵树上所有的父子关系，求这棵树的高度
### 输入描述
```
输入的第一行表示节点的个数n（1 ≤ n ≤ 1000，节点的编号为0到n-1）组成，
下面是n-1行，每行有两个整数，第一个数表示父节点的编号，第二个数表示子节点的编号
```
### 输出描述
```
输出树的高度，为一个整数
```
### 测试样例
#### 样例1:输入-输出-解释
```
5
0 1
0 2
1 3
1 4
```
```
3
```
```
无
```
### 题目来源  
`nowcoder.com`"
根据后序数组重建搜索二叉树_1580098878495,"### 题目描述
给定一个有 n 个不重复整数的数组 arr，判断 arr 是否可能是节点值类型为整数的搜索二叉树后序遍历的结果。
### 输入描述
```
第一行一个整数 n，表示数组的长度。
第二行 n 个整数 arr_i。
```
### 输出描述
```
如果是搜索二叉树后序遍历的结果则输出 ""true""，否则输出 ""false""。
```
### 测试样例
#### 样例1:输入-输出-解释
```
3
1 3 2
```
```
true
```
```
无
```
### 题目来源  
`nowcoder.com`"
根据字符出现频率排序_1580561898191,"### 题目描述
给定一个字符串，请将字符串里的字符按照出现的频率降序排列。
### 输入描述
```
一个字符串
```
### 输出描述
```
排好序的字符串
```
### 测试样例
#### 样例1: 输入-输出-解释
```
tree
```
```
eert
```
```
'e'出现两次，'r'和't'都只出现一次。
因此'e'必须出现在'r'和't'之前。此外，""eetr""也是一个有效的答案。
```
### 题目来源  
`LeetCode`"
梦中的统计_1581142162901,"### 题目描述
按照给定的起始顶点广度优先遍历图，每一次通过字母顺序选择顶点查找下一层邻接点，打印遍历顺序。
### 输入描述
```
Bessie 处于半梦半醒的状态。过了一会儿，她意识到她在数数，不能入睡
Bessie的大脑反应灵敏，仿佛真实地看到了她数过的一个又一个数。她开始注意每一个数码(0..9)：每一个数码在计数的过程中出现过多少次？
给出两个整数M 和N (1 ≤M ≤N ≤2,000,000,000 以及N-M ≤500,000)，求每一个数码出现了多少次。
例如考虑序列129--137: 129, 130, 131, 132, 133, 134, 135, 136, 137。统计后发现：
0出现了1次，1出现了10次，2出现了2次，3出现了9次，4出现了1次，5出现了1次，
6出现了1次，7出现了1次，8出现了0次，9出现了1次。
```
### 输出描述
```
第1行: 两个用空格分开的整数M 和N
```
### 测试样例
#### 样例1:输入-输出-解释
```
129 137
```
```
1 10 2 9 1 1 1 1 0 1
```
```
无
```
### 题目来源  
`luogu.com.cn`"
检查两个数组是否相等_1580299182125,"### 题目描述
给定两个大小为N的数组A和B，任务是查找给定的数组是否相等。如果两个数组都包含相同的元素集，则称两个数组相等，但是元素的排列（或排列）可能会不同。 注意：如果存在重复，则重复元素的计数也必须相同，以使两个数组相等。
### 输入描述
输入的第一行包含一个整数T，表示测试用例的数量。然后是T测试用例。每个测试用例包含3行输入。第一行包含一个整数N，它表示数组的大小。第二行包含数组A []的元素。第三行包含数组B []的元素。
### 输出描述
对于每个测试用例，如果数组相等，则打印1，否则打印0。
### 输入范例
```
2
5
1 2 5 4 0
2 4 5 0 1
3
1 2 5
2 4 15
```
### 输出范例
```
1
0
```
### 题目来源
geeksforgeeks.org
"
水壶问题_1578056371391,"## 题目描述
<p>有两个容量分别为&nbsp;<em>x</em>升 和<em> y</em>升 的水壶以及无限多的水。请判断能否通过使用这两个水壶，从而可以得到恰好&nbsp;<em>z</em>升 的水？</p>
<p>如果可以，最后请用以上水壶中的一或两个来盛放取得的&nbsp;<em>z升&nbsp;</em>水。</p>
<p>你允许：</p>
<ul>
	<li>装满任意一个水壶</li>
	<li>清空任意一个水壶</li>
	<li>从一个水壶向另外一个水壶倒水，直到装满或者倒空</li>
</ul>
<p><strong>示例 1:</strong> (From the famous <a href=""https://www.youtube.com/watch?v=BVtQNK_ZUJg""><em>""Die Hard""</em> example</a>)</p>
<pre>输入: x = 3, y = 5, z = 4
输出: True
</pre>
<p><strong>示例 2:</strong></p>
<pre>输入: x = 2, y = 6, z = 5
输出: False
</pre>"
求到达数组末端的最小移动数_1577371584339,"## 题目描述
给定一个大小为N的数组arr[]，其中每个元素都来自[0,9]范围。任务是从第一个索引开始到达数组的最后一个索引。我们可以从第i个索引移动到(i - 1)th、(i + 1)th或任何j≠i和arr[j] = arr[i]的第j个索引。
## 输入描述
一个自然数数组
## 输出描述
一个整数
## 样例输入
arr[] = {1, 2, 3, 4, 1, 5}
## 样例输出
2
## 题目来源
geeksforgeeks.org"
求和树_1580193300037,"### 题目描述
给满出二叉树，编写算法将其转化为求和树
什么是求和树：二叉树的求和树， 是一颗同样结构的二叉树，其树中的每个节点将包含原始树中的左子树和右子树的和。
二叉树：
                  10
               /      \
             -2        6
           /   \      /  \ 
          8    -4    7    5
求和树：
                 20(4-2+12+6)
               /      \
           4(8-4)      12(7+5)
            /   \      /  \ 
          0      0    0    0
二叉树给出前序和中序输入，求和树要求中序输出；
所有处理数据不会大于int；
### 输入描述
```
2行整数，第1行表示二叉树的前序遍历，第2行表示二叉树的中序遍历，以空格分割
```
### 输出描述
```
1行整数，表示求和树的中序遍历，以空格分割
```
### 测试样例
#### 样例1:输入-输出-解释
```
10 -2 8 -4 6 7 5 
8 -2 -4 10 7 6 5
```
```
0 4 0 20 0 12 0
```
```
无
```
### 题目来源  
`nowcoder.com`"
求字符串所有后缀贡献最大值_1578284624254,"### 题目描述
由于你成功地在1s内算出了上一题的答案，英雄们很高兴并邀请你加入了他们的游戏。然而进入游戏之后你才发现，英雄们打的游戏和你想象的并不一样……
英雄们打的游戏是这样的：首先系统会产生（注意不一定是随机产生）一个字符串，然后每个英雄就会开始根据自己分到的任务计算这个字符串的某些特征，谁先算出自己的答案谁就是胜者。
由于打游戏的英雄比较多，因此英雄们分到的任务也就可能很奇怪。比如你分到的这个任务就是这样：
定义这个字符串以第i个字符开头的后缀为后缀i (编号从 1开始)，每个后缀 i都有一个权值Wi，同时定义两个后缀i,j(i≠j) 的贡献为它们的最长公共前缀长度加上它们权值的异或和，也就是LCP(i,j) + (wi xor wj)。而你的任务就是，求出这个字符串的所有后缀两两之间贡献的最大值。
### 输入描述
```
第一行一个正整数n,表示字符串的长度。
第二行一个仅包含小写英文字母的字符串，即系统产生的字符串。
第三行n个非负整数Wi,分别表示后缀1 ~ n的权值。
```
### 输出描述
```
一行一个整数表示答案。
```
### 测试样例
#### 样例1:输入-输出-解释
```
7
acbabac
0 1 5 6 4 2 3
```
```
7
```
```
后缀1和后缀4的贡献是1+(0 xor 6) = 7，不难验证它们的贡献确实是所有可能的贡献中最大的。
```"
求权值和最小的边集的子集_1578216688887,"### 题目描述
给定一个n个点m条边的带权有向图，不存在自环，可能存在重边。求出一个权值和最小的边集的子集，使得存在至少一个点可以通过这些边到达所有点。
### 输入描述
```
第一行两个整数n,m。
接下来m行一行三个整数u,v,w，表示一条从u到v权值为w的有向边。
数据范围：
对于全部数据，1≤n≤500,1≤m≤n(n-1)/2, u_i ≠ v_i(符号""_""表示下标), 1≤W_i≤10^9。
子任务1(points: 20): n ≤ 10
子任务2(points: 20): n ≤ 50
子任务3(points: 30): n ≤ 100
子任务4(points: 30): n ≤ 500
```
### 输出描述
```
输出一行一个整数表示满足要求的集合的最小权值和；若不存在，输-1。
```
### 测试样例
#### 样例1:输入-输出-解释
```
5 9
2 5 12
3 2 9
2 5 10
5 4 4
5 3 7
4 3 8
3 4 8
2 3 4
4 1 3
```
```
21
```"
波浪数组_1580299515242,"### 题目描述
给定一个无重复整数且没有重复的排序数组arr []。将数组排序为类似波浪的数组，然后将其返回。换句话说，将元素排列为a1> = a2 <= a3> = a4 <= a5 .....的顺序（按照字典顺序递增）。
### 输入描述
第一行包含一个整数T，表示测试用例的总数。随后是T个测试用例。每个测试用例的第一行包含一个整数N，它描述了数组的大小。第二行包含数组的N个空格分隔的元素。
### 输出描述
对于每个测试用例，在新行中，将数组打印为波形数组。
### 输入范例
```
1
5
1 2 3 4 5
```
### 输出范例
```
2 1 4 3 5
```
### 题目来源
geeksforgeeks.org
"
灯泡开关_1578053846249,"## 题目描述
<p>初始时有&nbsp;<em>n&nbsp;</em>个灯泡关闭。 第 1 轮，你打开所有的灯泡。 第 2 轮，每两个灯泡你关闭一次。 第 3 轮，每三个灯泡切换一次开关（如果关闭则开启，如果开启则关闭）。第&nbsp;<em>i</em> 轮，每&nbsp;<em>i&nbsp;</em>个灯泡切换一次开关。 对于第&nbsp;<em>n&nbsp;</em>轮，你只切换最后一个灯泡的开关。 找出&nbsp;<em>n&nbsp;</em>轮后有多少个亮着的灯泡。</p>
<p><strong>示例:</strong></p>
<pre><strong>输入: </strong>3
<strong>输出:</strong> 1 
<strong>解释:</strong> 
初始时, 灯泡状态 <strong>[关闭, 关闭, 关闭]</strong>.
第一轮后, 灯泡状态 <strong>[开启, 开启, 开启]</strong>.
第二轮后, 灯泡状态 <strong>[开启, 关闭, 开启]</strong>.
第三轮后, 灯泡状态 <strong>[开启, 关闭, 关闭]</strong>. 
你应该返回 1，因为只有一个灯泡还亮着。
</pre>"
特殊奇数和_1578227956049,"## 题目描述
给定n的值，我们需要找到序列之和，其中第i个项是第一个i个奇数自然数之和。Note:n的序列之和=1 + (1+3) + (1+3+5) + (1+3+5+7) + …… + (1+3+5+7+…+(2n-1))
## 输入描述
输入的第一行包含一个整数T，表示测试用例的数量。然后是T测试用例，输入的单行包含一个正整数N。1<=T<=100；1<=N<=1000
## 输出描述
打印每个测试用例的序列之和。
## 样例输入
2
2
5
## 样例输出
5
55
## 题目来源
geeksforgeeks.org"
特殊序列和_1578276936192,"## 题目描述
给定n的值，我们需要找到第i个项是第i个自然数之和的级数之和。 序列和=（1 + 2）+（1 + 2 + 3）+（1 + 2 + 3 + 4）+……+（1 + 2 + 3 + 4 +…+ n）
## 输入描述
输入的第一行包含一个整数T，表示测试用例的数量。然后是T测试用例，输入的单行包含一个正整数N。1<=T<=100；
1<=N<=1000
## 输出描述
打印每个测试用例的N个术语系列的总和。
## 样例输入
2
5
10
## 样例输出
35
220
## 题目来源
geeksforgeeks.org"
独特的树叶_1579277545959,"### 题目描述
JYY 有两棵树A和B：树A有N个点，编号为1到N；树B有N+1个点，编号为1到N+1。
JYY 知道树B恰好是由树A加上一个叶节点，然后将节点的编号打乱后得到的。他想知道，这个多余的叶子到底是树B中的哪一个叶节点呢？
### 输入描述
```
输入一行包含一个正整数N。 接下来N-1行，描述树A，每行包含两个整数表示树A中的一条边； 接下来N行，描述树B，每行包含两个整数表示树B中的一条边。```
### 输出描述
```
输出一行一个整数，表示树B中相比树A多余的那个叶子的编号。如果有多个符合要求的叶子，输出B中编号最小的那一个的编号。
```
### 测试样例
#### 样例1:输入-输出-解释
```
5
1 2
2 3
1 4
1 5
1 2
2 3
3 4
4 5
3 6
```
```
1
```
```
对于所有数据，1≤N≤10^5。
```
"
猫咪_1578285738249,"### 题目描述
大 F 想养猫。
    “你喜欢小猫咪吗？”
    “喵。”
    “你变成猫了吗？”
    “喵！”
大 F 喜欢小猫咪，大 F 想养很多很多小猫咪，但是大 F 的想象力十分匮乏，她希望小 F 来帮她为猫咪们取名字。
小F也喜欢小猫咪,小F也想养许多许多小猫咪,但是小F有强迫症，如果养了K只猫咪,名字分别是非空字符串S1, S2,... Sk,她希望对于所有的2≤i≤K, Si 是 S(i-1) 的双子串。另外,小F还希望S1是她自己给定的字符串T的子串。
诶,我们刚刚提到了双子串。字符串A被称作B的双子串,意思是说，A作为B的子串,在B中的不同位置出现了至少2次。比如说，ABC 是ZZABCZZABCZZ的双子串,ABA是ABABA的双子串(这里的两次出现有重叠部分，这是允许的)，而 AAB不是AABAB的双子串。
小F想养尽量多的猫咪,所以小F想要找到尽量大的K,使得存在S1, S2..., Sk满足条件。
### 输入描述
```
一行一个字符串T，仅含小写字母。
数据范围：
对于所有数据，保证1 ≤ N = |T| ≤ 2 x 10^5, S仅含小写字母。
1
```
### 输出描述
```
一个整数，可能的K的最大值。
```
### 测试样例
#### 样例1:输入-输出-解释
```
qaqaqzz
```
```
3
```
```
S1 = qaqaqzz
S2 = qaq
S3 = q
```"
生成二进制数_1578140920564,"## 题目描述
给定数字N。任务是生成并打印具有从1到N的十进制值的所有二进制数。
## 输入描述
输入的第一行包含一个整数T，它表示测试用例的数量。每个包含N的测试用例只有一行。1 ≤ T ≤ 10^6;1 ≤ N ≤ 10^6
## 输出描述
在一行中打印所有具有十进制值从1到N的二进制数字。
## 样例输入
2
2
5
## 样例输出
1 10
1 10 11 100 101
## 题目来源
geeksforgeeks.org"
生成树求和_1578205904961,"### 题目描述
给定一张n个点m条边的带权无向图G，对于G的每一棵生成树，我们定义这棵生成树的权值为：它所包含的所有边的边权按三进制不进位加法相加所得的数。
现在请你求出图G中所有的生成树的权值和（将生成树的权值由三进制转为十进制，做正常的十进制进位加法）。输出答案对10^9 + 7取模后的值即可。
### 输入描述
```
第一行两个整数n,m表示点数与边数。点从1~n编号。
接下来m行每行三个整数a,b,c表示一条连接(a,b)的边权为c的无向边。
边权以十进制形式给出。
数据范围：
30%的数据(共六个点) : n= 5,6,7,8,9,10
50%的数据:n≤30
70%的数据:n≤40
100%的数据:n≤100,m≤n(n-1)/2,0≤c≤10^4,保证无重边无自环。
```
### 输出描述
```
仅一行一个整数表示答案。
```
### 测试样例
#### 样例1:输入-输出-解释
```
5 7
3 2 7400
4 1 1618
4 2 9110
4 3 4264
5 1 537
5 2 4240
5 3 655
```
```
262221
```"
生成魔咒_1578244508151,"### 题目描述
魔咒串由许多魔咒字符组成，魔咒字符可以用数字表示。例如可以将魔咒字符1、2拼凑起来形成一个魔咒串[1,2]。
一个魔咒串S的非空子串被称为魔咒串S的生成魔咒。
例如S=[1,2,1]时，它的生成魔咒有[1]、[2]、[1,2]、[2,1]、[1,2,1]五种。S=[1,1,1]时，它的生成魔咒有[1]、[1,1]、[1,1,1]三种。
最初S为空串。共进行n次操作，每次操作是在S的结尾加入一个魔咒字符。每次操作后都需要求出，当前的魔咒串S共有多少种生成魔咒。
### 输入描述
```
第一行一个整数n。
第二行n个数，第i个数表示第i次操作加入的魔咒字符。
数据范围：
用来表示魔咒字符的数字x满足1≤x≤10^9。
```
### 输出描述
```
输出n行，每行一个数。第i行的数表示第i次操作后S的生成魔咒数量。
```
### 测试样例
#### 样例1:输入-输出-解释
```
7
1 2 3 3 3 1 2
```
```
1
3
6
9
12
17
22
```"
甲苯先生和大中锋的字符串_1578280226332,"### 题目描述
大中锋有一个长度为n的字符串，他只知道其中的一个子串是祖上传下来的宝藏的密码。但是由于字符串很长，大中锋很难将这些子串一一尝试。
这天大中锋找到甲苯先生算命，但是甲苯先生说：「天机不可泄漏」。在大中锋的苦苦哀求下，甲苯先生告诉大中锋：「密码是在字符串中恰好出现了k次的子串」。
但是大中锋不知道该怎么做，在大中锋再三的恳求下，甲苯先生看其真诚，又告诉他：「在恰好出现了k次的子串中，你去按照字串的长度分类，密码就在数量最多的那一类里」。
大中锋为了尝试这个密码，想让你帮忙找出子串长度出现次数最多的长度数（如果有多个输出最长长度）。
### 输入描述
```
第一行一个正整数T，表示有T组测试数据。
接下来T行，每行包含一个字符串和一个正整数k。
```
### 输出描述
```
一共输出T行，每行一个整数表示在出现k次的子串中出现次数的最多的长度。
如果不存在子串出现k次，则输出-1。
```
### 测试样例
#### 样例1:输入-输出-解释
```
6
aab 1
abc 1
aaaa 2
abab 2
ababacc 2
abab 4
```
```
2
1
3
1
2
-1
```
```
对于第一个数据:其中子串b，aa，ab， aab 均只出现一次,其中长度为1的子串出现了1次,长度为2的子串出现了2次,长度为3的子串出现了1次。所以答案为2。
对于第二个数据:其中子串a, b, c，ab, bc, abc 均只出现一次,其中长度为1的子串出现了3次,长度为2的子串出现了2次,长度为3的子串出现了1次。所以答案为1。
对于第三个数据:中子串aaa出现二次,长度为3的子串出现了1次,其他长度均没有。所以答案为3。
对于第四个数据:中子串a, b，ab 出现二次,中长度为1的子串出现了2次，长度为2的子串出现了1次。所以答案为1.
对于第五个数据:中子串b，c，ab，ba 出现二次,其中长度为1的子串出现了2次,长度为2的子串出现了2次。所以答案为2。
对于第六个数据:其中子串没有出现四次。所以本题的答案为-1。
```"
电话号码_1581089735969,"### 题目描述
一串由长长的数字组成的电话号码通常很难记忆。为了方便记忆，有种方法是用单词来方便记忆。例如用“Three Tens”来记忆电话3-10-10-10。
电话号码的标准形式是七位数字，中间用连字号分成前三个和后四个数字（例如：888-1200）。电话号码可以用字母来表示。以下是字母与数字的对应：
A，B和C对应2
D，E和F对应3
G，H和I对应4
J，K和L对应5
M，N和O对应6
P，R和S对应7
T，U和V对应8
W，X和Y对应9
你会发现其中没有字母Q和Z。电话中的连字号是可以忽略。例如TUT-GLOP的标准形式是888-4567，310-GINO的标准形式是310-4466，3-10-10-10的标准形式是310-1010。
如果两个电话号码的标准形式是一样的，那么这两个电话号码就是一样的。
现在有一本电话簿，请从中找出哪些电话号码是重复的。
### 输入描述
```
第一行一个正整数N，表示有多少个电话号码。
以下N行，每行一个电话号码，电话号码由数字、大写字母（除Q、Z）和连字符组成。电话号码长度不会超过1000。所有电话号码都合法。
```
### 输出描述
```
将所有重复的电话号码按字典序以标准形式输出，并且在每个电话号码后跟一个整数，表示该电话号码共出现了多少次，电话号码和整数间用一个空格隔开。不要输出多余空行。
如果没有重复的电话号码，则输出：No duplicates.
```
### 测试样例
#### 输入
```
3
TUT-GLOP
3-10-10-10
310-1010
```
#### 输出
```
310-1010 2
```
"
皇室夫人的名字_1578290259363,"### 题目描述
众所周知，皇室家族的名字非常有讲究。而作为研究皇室的历史学家的你，最近接到了一个艰巨的任务——分析王国历史中所有皇室夫人的名字。
王国历史上有n位皇室夫人，方便起见，我们将其从1至n编号。除了1号夫人外，其余夫人的名字均为一个大写字母连接着她母亲的名字。而1号夫人作为王国的首任王后，她的名字只有一个大写字母。
例如，由于 AENERYS 由 A 与 ENERYS 组成，因此 ENERYS 是 AENERYS 的母亲。相似地，AENERYS 是 DAENERYS 与 YAENERYS 的母亲。
你知道王国历史上所有皇室夫人的姓名与关系，而你需要完成的任务是，对于其他历史学家感兴趣的名字串s，总共有多少位夫人的名字是以s起始的。
例如在样例的皇室族谱中，S 至 AENERYS 的这一支（包含 YS、RYS、ERYS、NERYS 与 ENERYS 这几位夫人）均只有一位女儿。接下来 AENERYS 有两位女儿，分别是 DAENERYS，以及女儿是 RYAENERYS 的 YAENERYS。
在这个皇室家族内，有两位夫人的名字以 RY 起始，她们是 RYS 与 RYAENERYS。而 ERYS 与 ENERYS 均以 E 起始。名字以 N 起始的仅有一位夫人 NERYS。同样地，以 S 起始的仅有首位王后 S。而没有任何一位夫人的名字以 AY 起始。
### 输入描述
```
第一行有两个整数n, k,分别代表国历史上皇室夫人总数，以及其他历史学家感兴趣的名字串的个数。
接下来n行描述所有皇室夫人的姓名与关系。第i + 1行描述第i位夫人的资料c_i(符号""_""表示下标)与p_i,其中字符C_i表示她名字的首位字母, p_i为她母亲的编号。对于编号为1的首位王后, P_1 = 0。所有夫人的名字均不重复。
接下来k行,每行为一个大写字母构成的非空串，代表一个其他历史学家感兴趣的名字串。
数据范围：对于1<i≤n,保证有1≤p_i<i。感兴趣的名字串总长不超过10^6。
```
### 输出描述
```
输出k行，第i行为一个整数，代表总共有多少位夫人的名字是以第i个感兴趣的名字串起始的。
```
### 测试样例
#### 样例1:输入-输出-解释
```
10 5
S 0
Y 1
R 2
E 3
N 4
E 5
A 6
D 7
Y 7
R 9
RY
E
N
S
AY
```
```
2
2
1
1
0
```"
直方图中的最大矩形面积_1578143334531,"## 题目描述
在给定的直方图中找到最大的矩形区域，其中最大的矩形可以由许多连续的条形组成。为简单起见，假设所有条形都具有相同的宽度，并且宽度为1个单位。
## 输入描述
第一行包含一个整数“ T”，表示测试用例的总数。随后是T个测试用例。在每个测试案例中，第一行都包含一个整数“ N”，表示数组的大小。第二行包含N个以空格分隔的整数A1，A2，...，AN，表示数组的元素。数组的元素表示条形的高度。1 <= T <= 100
；1 <= N <= 10^6；1 <= A[i] <= 10^18
## 输出描述
对于每个测试用例，在单独的一行中，连续条形可能的最大矩形区域。
## 样例输入
2
7
6 2 5 4 5 1 6
4
6 3 4 2
## 样例输出
12
9
## 题目来源
geeksforgeeks.org"
矩形围成一圈_1580709242736,"### 题目描述
给定一个半径为R的圆形薄片，找出可以从该薄片上切下具有整数长度和宽度的矩形的总数。
### 输入描述
输入的第一行包含一个整数T，表示测试用例的数量。然后是T测试用例。每个测试用例均包含一个整数R，该整数R表示圆形的半径。
### 输出描述
对应于每个测试用例，输出一个整数。
### 输入范例
```
1
2
```
### 输出范例
```
8
```
### 题目来源
geeksforgeeks.org
"
矩形面积_1578049968361,"## 题目描述
<p>在<strong>二维</strong>平面上计算出两个<strong>由直线构成的</strong>矩形重叠后形成的总面积。</p>
<p>每个矩形由其左下顶点和右上顶点坐标表示，如图所示。</p>
<p><img src=""https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rectangle_area.png"" alt=""Rectangle Area""></p>
<p><strong>示例:</strong></p>
<pre><strong>输入:</strong> -3, 0, 3, 4, 0, -1, 9, 2
<strong>输出:</strong> 45</pre>
<p><strong>说明:</strong> 假设矩形面积不会超出&nbsp;<strong>int&nbsp;</strong>的范围。</p>"
第k个排列_1577688544639,"## 题目描述
<p>给出集合&nbsp;<code>[1,2,3,…,<em>n</em>]</code>，其所有元素共有&nbsp;<em>n</em>! 种排列。</p>
<p>按大小顺序列出所有排列情况，并一一标记，当&nbsp;<em>n </em>= 3 时, 所有排列如下：</p>
<ol>
	<li><code>""123""</code></li>
	<li><code>""132""</code></li>
	<li><code>""213""</code></li>
	<li><code>""231""</code></li>
	<li><code>""312""</code></li>
	<li><code>""321""</code></li>
</ol>
<p>给定&nbsp;<em>n</em> 和&nbsp;<em>k</em>，返回第&nbsp;<em>k</em>&nbsp;个排列。</p>
<p><strong>说明：</strong></p>
<ul>
	<li>给定<em> n</em>&nbsp;的范围是 [1, 9]。</li>
	<li>给定 <em>k&nbsp;</em>的范围是[1, &nbsp;<em>n</em>!]。</li>
</ul>
<p><strong>示例&nbsp;1:</strong></p>
<pre><strong>输入:</strong> n = 3, k = 3
<strong>输出:</strong> ""213""
</pre>
<p><strong>示例&nbsp;2:</strong></p>
<pre><strong>输入:</strong> n = 4, k = 9
<strong>输出:</strong> ""2314""
</pre>"
等于0、1和2_1580736171649,"### 题目描述
给定一个仅包含0、1或2s的字符串，请计算具有相等数量0、1s和2s的子字符串的数量。
例子： 
输入：str =“ 0102010” 
输出2 
说明：
子字符串str [2，4] =“ 102”，并且               
子字符串str [4，6] =“ 201”
### 输入描述
输入的第一行包含一个整数T，表示测试用例的数量。然后是T测试用例。每个测试用例包含一行。该行包含0、1和2的字符串。
### 输出描述
对应于每个测试用例，在新的一行中，打印计数所有可能的具有相同的0、1、2和2s数目的子字符串。
### 输入范例
```
2
0102010
102100211
```
### 输出范例
```
2
5
```
### 题目来源
geeksforgeeks.org
"
简化阵列_1580309957332,"### 题目描述
给定一个大小为N的整数数组。假定“ 0”为无效数字，所有其他均为有效数字。编写程序以如下方式修改数组：如果下一个数字是有效数字并且与当前数字相同，则将当前数字值加倍，并将下一个数字替换为0。修改后，重新排列数组，使所有0都为移至末尾，则有效数字或新的双倍数字的顺序将保持原始数组中的顺序。
### 输入描述
输入的第一行包含一个整数T，表示测试用例的数量。然后是T测试用例。每个测试的第一行包含一个整数N，它表示数组的大小。然后，下一行包含N个以空格分隔的整数，它们表示数组的元素。
### 输出描述
For each test case print space separated elements of the new modified array on a new line.
### 输入范例
```
2
5
2 2 0 4 4
5
0 1 2 2 0
```
### 输出范例
```
4 8 0 0 0
1 4 0 0 0
```
### 题目来源
geeksforgeeks.org
"
索引计数_1580740517977,"### 题目描述
您将得到3个大小为N的不同数组A，B和C。
找到索引i的数量，使得： Ai = Bi + Ck 
其中k可以位于[1，N]之间。
### 输入描述
输入的第一行包含一个整数T，表示测试用例的数量。每个测试用例的第一行包含一个整数N，它表示数组的大小。的下3行分别包含数组A，B和C的N个空格分隔的整数。
### 输出描述
对于每个测试用例，打印满足给定条件的该索引的数量计数。
### 输入范例
```
1
3
1 2 3
3 2 4
0 5 -2
```
### 输出范例
```
2
```
### 题目来源
geeksforgeeks.org
"
给定总和的子数组_1580020054641,"### 题目描述
给定大小为N的非负整数的未排序数组A，找到一个连续的子数组，该数组加到给定的数字S上。
### 输入描述
输入的第一行包含一个整数T，表示测试用例的数量。然后是T测试用例。每个测试用例由两行组成。每个测试用例的第一行是N和S，其中N是数组的大小，S是总和。每个测试用例的第二行包含N个以空格分隔的整数，表示数组元素。
### 输出描述
对于每个测试用例，在新行中，如果sum等于子数组，则从左边开始打印第一个出现的子数组的开始和结束位置（1个索引），否则打印-1。
### 输入范例
```
2
5 12
1 2 3 7 5
10 15
1 2 3 4 5 6 7 8 9 10
```
### 输出范例
```
2 4
1 5
```
### 题目来源
geeksforgeeks.org"
统计和生成所有不同的二叉树_1580194109335,"### 题目描述
给出一个整数 n，如果 n < 1，代表空树，否则代表中序遍历的结果为 {1, 2, 3... n}。请输出可能的二叉树结构有多少。
### 输入描述
```
第一行输入一个整数 n。
```
### 输出描述
```
输出一个整数对 1e9 + 7 取模的值表示答案。
```
### 测试样例
#### 样例1:输入-输出-解释
```
7
```
```
429
```
```
无
```
### 题目来源  
`nowcoder.com`"
罗马数字转整数_1577682190777,"## 题目描述
罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。
字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。
通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：
I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 
C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。
给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。
## 输入描述
罗马数字
# 输出描述
整数
## 样例输入
III
## 样例输出
3
"
翻转对_1580533703382,"### 题目描述
给定一个数组 nums ，如果 i < j 且 nums[i] > 2*nums[j] 我们就将 (i, j) 称作一个重要翻转对。
你需要返回给定数组中的重要翻转对的数量。
### 输入描述
```
一个数组。给定数组的长度不会超过50000。输入数组中的所有数字都在32位整数的表示范围内。
```
### 输出描述
```
翻转对数量
```
### 测试样例
#### 样例1: 输入-输出-解释
```
[1,3,2,3,1]
```
```
2
```"
自定义字符串排序_1580561130194,"### 题目描述
字符串S和 T 只包含小写字符。在S中，所有字符只会出现一次。
S 已经根据某种规则进行了排序。我们要根据S中的字符顺序对T进行排序。更具体地说，如果S中x在y之前出现，那么返回的字符串中x也应出现在y之前。
返回任意一种符合条件的字符串T。
### 输入描述
```
两行分别是字符串S和 T。S的最大长度为26，其中没有重复的字符。T的最大长度为200。S和T只包含小写字符。
```
### 输出描述
```
返回排好序的字符串T
```
### 测试样例
#### 样例1: 输入-输出-解释
```
cba
abcd
```
```
cbad
```
```
S中出现了字符 ""a"", ""b"", ""c"", 所以 ""a"", ""b"", ""c"" 的顺序应该是 ""c"", ""b"", ""a"". 
由于 ""d"" 没有在S中出现, 它可以放在T的任意位置. ""dcba"", ""cdba"", ""cbda"" 都是合法的输出。
```
### 题目来源  
`LeetCode`"
艾莉亚与大战_1580783766545,"### 题目描述
伟大的战争正在进行中。每个生物都在竭尽全力从死里拯救世界。艾莉亚全力以赴的战斗发现，白步行者需要以某种模式被杀死，否则他们将不会死亡。
她试图了解这种模式。她刺伤了每人“ N”次，杀死了每一个“ Xth”白步行者。
```
Whitewalker approaching order (X)    Number of times-stabbing(N)
1                                                                1
2                                                                1
3                                                                2
.                                                                 .
.                                                                 .
55                                                              5
.                                                                 .
98                                                              3
.                                                                  .
.                                                                  .
101                                                             4
.                                                                  .
.                                                                  .
.                                                                  .
198                                                              4
```
这是艾莉亚需要遵循的模式的暗示。帮助艾莉亚！
### 输入描述
输入的第一行包含一个整数T，表示测试用例的数量。每个测试用例的描述如下。每个测试用例包含一行，有一个整数'X'表示第X个白步行者。
### 输出描述
对于其中的每个测试用例，新的一行将显示杀死第X个白步行者所需的刺数。
### 输入范例
```
4
102
95
72
60
```
### 输出范例
```
4
6
2
4
```
### 题目来源
geeksforgeeks.org
"
节点的最近公共祖先_1580112448789,"### 题目描述
给定一棵二叉树以及这棵树上的两个节点 o1 和 o2，请找到 o1 和 o2 的最近公共祖先节点。
### 输入描述
```
第一行输入两个整数 n 和 root，n 表示二叉树的总节点个数，root 表示二叉树的根节点。
以下 n 行每行三个整数 fa，lch，rch，表示 fa 的左儿子为 lch，右儿子为 rch。(如果 lch 为 0 则表示 fa 没有左儿子，rch同理)
最后一行为节点 o1 和 o2。
```
### 输出描述
```
输出一个整数表示答案。
```
### 测试样例
#### 样例1:输入-输出-解释
```
8 1
1 2 3
2 4 5
4 0 0
5 0 0
3 6 7
6 0 0
7 8 0
8 0 0
4 5
```
```
2
```
```
无
```
### 题目来源  
`nowcoder.com`"
苹果树_1579408051351,"### 题目描述
<p align=""left"">
 <img src=""http://mooctest-code.oss-cn-shanghai.aliyuncs.com/static/media/tree/%E8%8B%B9%E6%9E%9C%E6%A0%91.png"" alt=""Sample""  width=""1000"" height=""150"">
</p >
### 输入描述
<p align=""left"">
 <img src=""http://mooctest-code.oss-cn-shanghai.aliyuncs.com/static/media/tree/%E8%8B%B9%E6%9E%9C%E6%A0%911.png"" alt=""Sample""  width=""1000"" height=""70"">
</p >
### 输出描述
<p align=""left"">
 <img src=""http://mooctest-code.oss-cn-shanghai.aliyuncs.com/static/media/tree/%E8%8B%B9%E6%9E%9C%E6%A0%912.png"" alt=""Sample""  width=""1000"" height=""55"">
</p >
### 测试样例
#### 样例1:输入-输出-解释
```
2
5 1
0 1 1
1 1 1
1 1 3
2 1 10
3 1 4
9 15
0 1 1
1 7 2
2 5 10
1 3 1
4 3 17
4 3 18
4 4 19
1 1 1
8 1 100
```
```
15
316
```
```
无
```
#### 样例2: 输入-输出-解释
```
3
3 1
0 1 1
1 1 1
1 1 3
7 20
0 1 1
1 7 2
2 5 10
1 3 1
4 3 17
4 3 18
4 4 19
5 1
0 1 1
1 1 1
1 1 3
2 1 10
3 1 4
```
```
5
245
15
```
```
无
```
### 题目来源  
`loj.ac`"
螺旋遍历矩阵_1580213547873,"### 题目描述
给定大小为M * N的矩阵mat [] []。遍历并以螺旋形式打印矩阵。
### 输入描述
输入的第一行包含一个整数T，表示测试用例的数量。然后是T测试用例。每个测试用例都有2行。第一行包含分别用空格分隔的M和N。第二行包含M * N个值，以空格分隔。
### 输出描述
元素以顺时针方向进行螺旋，并以单行显示。
### 输入范例
```
2
4 4
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16
3 4
1 2 3 4 5 6 7 8 9 10 11 12
```
### 输出范例
```
1 2 3 4 8 12 16 15 14 13 9 5 6 7 11 10
1 2 3 4 8 12 11 10 9 5 6 7
```
### 题目来源
geeksforgeeks.org
"
计数字词的出现次数_1578662468635,"### 题目描述
给定一个单词S和一个文本C。返回该单词在文本中的字谜出现的次数。
### 输入描述
```
输入的第一行包含一个整数T，它表示测试用例的数量。 T测试用例的描述如下。每个测试用例的第一行包含仅包含小写字符的文本S。 第二行包含一个仅包含小写字母的单词。
1 <= T <= 50
1 <= |S| <= |C| <= 50
```
### 输出描述
```
打印文本S中单词C的出现的次数（顺序可以不同）。
```
### 测试样例
#### 样例1:输入-输出
```
2
forxxorfxdofr
for
aabaabaa
aaba
```
```
3
4
```
### 题目来源
geeksforgeeks.org"
计算可能的三角形_1580456177340,"### 题目描述
给定一个未排序的正整数数组。查找可以用三个不同的数组元素形成的三角形数，作为三角形三个边的长度。
### 输入描述
输入的第一行包含T，表示测试用例的数量。测试用例的第一行是数组N的长度，测试用例的第二行是其元素。
### 输出描述
向用户显示可能的三角形数量。
### 输入范例
```
2
3
3 5 4
5
6 4 9 7 8
```
### 输出范例
```
1
10
```
### 题目来源
geeksforgeeks.org
"
计算差异为k的不重复对_1580613441446,"### 题目描述
给定一个整数数组和一个非负整数k，对所有不同的对进行计数，它们的差等于k，即A [i]-A [j] = k。
### 输入描述
输入的第一行包括测试用例的数量。 T测试用例的描述如下： 每个测试用例的第一行包含数组的大小，第二行包含数组的元素，第三行包含差k。
### 输出描述
在每行打印中，数组元素之间存在差k的次数。
### 输入范例
```
3
5 
1 5 4 1 2
0
3
1 1 1
0
3 
1 5 3
2
```
### 输出范例
```
1
1
2
```
### 题目来源
geeksforgeeks.org
"
计算矩阵对的总和_1580629330600,"### 题目描述
给定两个元素大小为N x N的矩阵mat1和mat2。给定值x。问题是要计算两个矩阵之和等于x的所有对。
### 输入描述
第一行包含一个整数T，即测试用例的数量。每个测试用例的第一行包含两个整数N，x表示平方矩阵的大小。接下来的2 * N行包含N个由空格分隔的整数。
### 输出描述
对于每个测试用例，打印计数。
### 输入范例
```
1
3 21
1 5 6
8 10 11
15 16 18
2 4 7
9 10 12
13 16 20
```
### 输出范例
```
4
```
### 题目来源
geeksforgeeks.org
"
计算逆转_1580627331854,"### 题目描述
给定一个仅由大括号'{'和'}'组成的字符串S，找出能够平衡表达式所需的最小反转次数。
### 输入描述
输入的第一行包含一个整数T，表示测试用例的数量。然后是T测试用例。每个测试用例的第一行包含仅由{和}组成的字符串S。
### 输出描述
打印出使S平衡所需的最小反转。如果无法平衡，则打印-1。
### 输入范例
```
4
}{{}}{{{
{{}}}}
{{}{{{}{{}}{{
{{{{}}}}
```
### 输出范例
```
3
1
-1
0
```
### 题目来源
geeksforgeeks.org
"
超级丑数_1578053720076,"## 题目描述
<p>编写一段程序来查找第 <code><em>n</em></code> 个超级丑数。</p>
<p>超级丑数是指其所有质因数都是长度为&nbsp;<code>k</code>&nbsp;的质数列表&nbsp;<code>primes</code>&nbsp;中的正整数。</p>
<p><strong>示例:</strong></p>
<pre><strong>输入:</strong> n = 12, <code>primes</code> = <code>[2,7,13,19]</code>
<strong>输出:</strong> 32 
<strong>解释: </strong>给定长度为 4 的质数列表 primes = [2,7,13,19]，前 12 个超级丑数序列为：[1,2,4,7,8,13,14,16,19,26,28,32] 。</pre>
<p><strong>说明:</strong></p>
<ul>
	<li><code>1</code>&nbsp;是任何给定&nbsp;<code>primes</code>&nbsp;的超级丑数。</li>
	<li>&nbsp;给定&nbsp;<code>primes</code>&nbsp;中的数字以升序排列。</li>
	<li>0 &lt; <code>k</code> ≤ 100, 0 &lt; <code>n</code> ≤ 10<sup>6</sup>, 0 &lt; <code>primes[i]</code> &lt; 1000 。</li>
	<li>第&nbsp;<code>n</code>&nbsp;个超级丑数确保在 32 位有符整数范围内。</li>
</ul>"
超级次方_1578119933462,"## 题目描述
<p>你的任务是计算&nbsp;<em>a</em><sup><em>b</em></sup>&nbsp;对&nbsp;1337 取模，<em>a</em> 是一个正整数，<em>b</em> 是一个非常大的正整数且会以数组形式给出。</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入: </strong>a = 2, b = [3]
<strong>输出: </strong>8
</pre>
<p><strong>示例&nbsp;2:</strong></p>
<pre><strong>输入: </strong>a = 2, b = [1,0]
<strong>输出: </strong>1024</pre>"
路径交叉_1578055074509,"## 题目描述
<p>给定一个含有&nbsp;<code>n</code>&nbsp;个正数的数组&nbsp;<em>x</em>。从点&nbsp;<code>(0,0)</code>&nbsp;开始，先向北移动&nbsp;<code>x[0]</code>&nbsp;米，然后向西移动&nbsp;<code>x[1]</code>&nbsp;米，向南移动&nbsp;<code>x[2]</code>&nbsp;米，向东移动&nbsp;<code>x[3]</code>&nbsp;米，持续移动。也就是说，每次移动后你的方位会发生逆时针变化。</p>
<p>编写一个&nbsp;<code>O(1)</code>&nbsp;空间复杂度的一趟扫描算法，判断你所经过的路径是否相交。</p>
<p>&nbsp;</p>
<p><strong>示例&nbsp;1:</strong></p>
<pre><strong>┌───┐
│ &nbsp; │
└───┼──&gt;
&nbsp; &nbsp; │
输入: </strong><code>[2,1,1,2]</code>
<strong>输出:</strong> true 
</pre>
<p><strong>示例&nbsp;2:</strong></p>
<pre><strong>┌──────┐
│ &nbsp; &nbsp; &nbsp;│
│
│
└────────────&gt;
输入: </strong><code>[1,2,3,4]</code>
<strong>输出: </strong>false 
</pre>
<p><strong>示例 3:</strong></p>
<pre><strong>┌───┐
│ &nbsp; │
└───┼&gt;
输入:</strong> <code>[1,1,1,1]</code>
<strong>输出:</strong> true 
</pre>"
道路阻断_1578135605089,"### 题目描述
Farmer John 自豪于他所经营的交通发达的农场。这个农场是由N块牧场组成的，N-1条双向道路将它们连接起来，每一条道路的长度都为1单位长度。Farmer John 注意到，任意两个牧场都是互相可达的。
尽管 FJ 的农场现在是连通的，但他担心如果有一条道路被阻断会发生什么。事实上，这会将他的农场分为两个不相交的牧场集合，奶牛们只能在一个集合内移动但不能在集合间移动。于是 FJ 又建造了M条额外的双向道路，每一条的长度均为一个至多为10^9的正整数。奶牛们仍然可以使用未被阻断的原有道路进行移动。
如果某条原有的道路被阻断了，农场就会被分为两块不相交的区域，那么 FJ 就会从他的额外修建的道路中选择一条能够使这两块区域连通的，取代原来那条，从而奶牛们又可以从任何一块牧场去往另一块牧场。
对于农场上每一条原有的道路，帮助 FJ 选出最短的替代用的道路。
### 输入描述
```
输入的第一行包含N和M。
接下来的N-1行，每行用整数p和q描述了一条原有的道路，其中p,q是这条道路连接的两块牧场。
剩下的M行，每行用三个整数p,q和r描述了一条额外的道路，其中r是这条道路的长度。任何两块牧场之间至多只有一条额外的道路。
数据范围：
对于全部数据，2≤N≤5x10^4 , 1≤M≤5x10^4 , 1≤P , q≤N , p≠q。
```
### 输出描述
```
对原有的N-1条道路的每一条，按照它们在输入中出现的顺序，输出如果这条道路被阻断的话，能够重新连接农场的最短的替代用道路的长度。如果不存在合适的替代用的道路，输出-1。
```
### 测试样例
#### 样例1:输入-输出-解释
```
6 3
1 2
1 3
4 1
4 5
6 5
2 3 7
3 6 8
6 4 5
```
```
7
7
8
5
5
```"
长度总和_1580737573597,"### 题目描述
给定一个数组。编写一个程序来计算具有所有不同元素的连续子数组的长度总和。
### 输入描述
输入的第一行包含一个整数T，它表示测试用例的数量。然后是T测试用例。每个测试用例的第一行包含一个整数N，该整数N表示数组中元素的数量。每个测试用例的第二行包含N个以空格分隔的整数。
### 输出描述
对于每个测试用例，打印具有所有不同元素的连续子数组的长度总和。
### 输入范例
```
3
3
1 2 3
3
1 2 1
4
1 2 3 4
```
### 输出范例
```
10
7
20
```
### 题目来源
geeksforgeeks.org
"
长度最小的子数组_1580454672018,"### 题目描述
<p>给定一个含有&nbsp;<strong>n&nbsp;</strong>个正整数的数组和一个正整数&nbsp;<strong>s ，</strong>找出该数组中满足其和<strong> ≥ s </strong>的长度最小的连续子数组<strong>。</strong>如果不存在符合条件的连续子数组，返回 0。</p>
<p><strong>示例:&nbsp;</strong></p>
<pre><strong>输入:</strong> <code>s = 7, nums = [2,3,1,2,4,3]</code>
<strong>输出:</strong> 2
<strong>解释: </strong>子数组&nbsp;<code>[4,3]</code>&nbsp;是该条件下的长度最小的连续子数组。
</pre>
<p><strong>进阶:</strong></p>
<p>如果你已经完成了<em>O</em>(<em>n</em>) 时间复杂度的解法, 请尝试&nbsp;<em>O</em>(<em>n</em> log <em>n</em>) 时间复杂度的解法。</p>
### 样例输入<br>
```
7
2,3,1,2,4,3
```
### 样例输出<br>
```
2
```
### 题目来源  
`LeetCode`"
阶乘后的零_1578048826487,"## 题目描述
<p>给定一个整数 <em>n</em>，返回 <em>n</em>! 结果尾数中零的数量。</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> 3
<strong>输出:</strong> 0
<strong>解释:</strong>&nbsp;3! = 6, 尾数中没有零。</pre>
<p><strong>示例&nbsp;2:</strong></p>
<pre><strong>输入:</strong> 5
<strong>输出:</strong> 1
<strong>解释:</strong>&nbsp;5! = 120, 尾数中有 1 个零.</pre>
<p><strong>说明: </strong>你算法的时间复杂度应为&nbsp;<em>O</em>(log&nbsp;<em>n</em>)<em>&nbsp;</em>。</p>"
隔离链接列表中的偶数和奇数节点_1578225498823,"## 题目描述
给定整数链接列表，编写一个函数来修改链接列表，以使所有偶数出现在修改后的链接列表中的所有奇数之前。另外，请保持偶数和奇数的顺序相同。
## 输入描述
输入的第一行包含一个整数T，它表示测试用例的数量。 每个测试用例的第一行是N，N是链表中元素的数量。 每个测试用例的第二行在链表中包含N个输入元素。1 ≤ T ≤ 100;1 ≤ N ≤ 100;1 ≤ size of elements ≤ 1000
## 输出描述
在修改后的“链表”中打印所有偶数，然后打印奇数。
## 样例输入
3
7
17 15 8 9 2 4 6
4
1 3 5 7
7
8 12 10 5 4 1 6
## 样例输出
8 2 4 6 17 15 9
1 3 5 7
8 12 10 4 6 5 1
## 题目来源
geeksforgeeks.org"
颜色分类_1580444384416,"### 题目描述
给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。
此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。
### 输入描述
```
一个未排序的数组
```
### 输出描述
```
排好序的数组
```
### 测试样例
#### 样例1: 输入-输出-解释
```
[2,0,2,1,1,0]
```
```
[0,0,1,1,2,2]
```"
餐厅过滤器_1580557412562,"### 题目描述
给你一个餐馆信息数组 restaurants，其中  restaurants[i] = [idi, ratingi, veganFriendlyi, pricei, distancei]。你必须使用以下三个过滤器来过滤这些餐馆信息。
其中素食者友好过滤器 veganFriendly 的值可以为 true 或者 false，如果为 true 就意味着你应该只包括 veganFriendlyi 为 true 的餐馆，为 false 则意味着可以包括任何餐馆。此外，我们还有最大价格 maxPrice 和最大距离 maxDistance 两个过滤器，它们分别考虑餐厅的价格因素和距离因素的最大值。
过滤后返回餐馆的 id，按照 rating 从高到低排序。如果 rating 相同，那么按 id 从高到低排序。简单起见， veganFriendlyi 和 veganFriendly 为 true 时取值为 1，为 false 时，取值为 0 。
1 <= restaurants.length <= 10^4
restaurants[i].length == 5
1 <= idi, ratingi, pricei, distancei <= 10^5
1 <= maxPrice, maxDistance <= 10^5
veganFriendlyi 和 veganFriendly 的值为 0 或 1 。
所有 idi 各不相同。
### 输入描述
```
一个餐馆信息数组 restaurants，其中  restaurants[i] = [idi, ratingi, veganFriendlyi, pricei, distancei]。素食者友好过滤器 veganFriendly，以及最大价格 maxPrice 和最大距离 maxDistance 两个过滤器。
```
### 输出描述
```
返回餐馆的 id，按照 rating 从高到低排序。如果 rating 相同，那么按 id 从高到低排序。
```
### 测试样例
#### 样例1: 输入-输出-解释
```
[[1,4,1,40,10],[2,8,0,50,5],[3,8,1,30,4],[4,10,0,10,3],[5,1,1,15,1]]
1
50
10
```
```
[3,1,5]
```
```
这些餐馆为：
餐馆 1 [id=1, rating=4, veganFriendly=1, price=40, distance=10]
餐馆 2 [id=2, rating=8, veganFriendly=0, price=50, distance=5]
餐馆 3 [id=3, rating=8, veganFriendly=1, price=30, distance=4]
餐馆 4 [id=4, rating=10, veganFriendly=0, price=10, distance=3]
餐馆 5 [id=5, rating=1, veganFriendly=1, price=15, distance=1] 
在按照 veganFriendly = 1, maxPrice = 50 和 maxDistance = 10 进行过滤后，我们得到了餐馆 3, 餐馆 1 和 餐馆 5（按评分从高到低排序）。 
```
### 题目来源  
`LeetCode`"
魔方俱乐部_1578209813393,"### 题目描述
fateice 来到了魔方俱乐部旅行。
魔方俱乐部有N个分部，每个分部均有且仅有一个虫洞，但是这虫洞只能通往一个分部。
每个分部有一个 orzFang 价值，第i个分部的 orzFang 价值为Ai。
现在他想知道，从第i个分部出发，并只通过虫洞前往下一个分部，orzFang 价值之和最多是多少（到达一个分部多次只计算1次 orzFang 价值）。
### 输入描述
```
第一行为一个正整数N。
第二行有N个非负整数Ai,表示了每个分部的orzFang价值。
第三行有N个正整数Fi,表示通过第i个分部的虫洞所到达的分部为Fi,可能出现Fi = i的情况。
数据范围：
对于20%的数据，N≤10.
对于40%的数据，N≤1000。
对于100%的数据，1≤N≤2x10^5，1≤Ai≤10^4
```
### 输出描述
```
包括N行，第i行包含一个非负整数，表示从第i个分部出发，orzFang 价值之和的最大值为多少。
```
### 测试样例
#### 样例1:输入-输出-解释
```
8
5 4 3 2 1 1 1 1
2 3 1 1 2 7 6 8
```
```
12
12
12
14
13
2
2
1
```"
